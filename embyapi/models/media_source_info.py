# coding: utf-8

"""
    Emby Server REST API

    Explore the Emby Server API

    The version of the OpenAPI document: 4.8.7.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import datetime
from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from embyapi.models.media_protocol import MediaProtocol
from embyapi.models.media_source_type import MediaSourceType
from embyapi.models.media_stream import MediaStream
from embyapi.models.transport_stream_timestamp import TransportStreamTimestamp
from embyapi.models.video3_d_format import Video3DFormat
from typing import Optional, Set
from typing_extensions import Self

class MediaSourceInfo(BaseModel):
    """
    MediaSourceInfo
    """ # noqa: E501
    protocol: Optional[MediaProtocol] = Field(default=None, alias="Protocol")
    id: Optional[StrictStr] = Field(default=None, alias="Id")
    path: Optional[StrictStr] = Field(default=None, alias="Path")
    encoder_path: Optional[StrictStr] = Field(default=None, alias="EncoderPath")
    encoder_protocol: Optional[MediaProtocol] = Field(default=None, alias="EncoderProtocol")
    type: Optional[MediaSourceType] = Field(default=None, alias="Type")
    probe_path: Optional[StrictStr] = Field(default=None, alias="ProbePath")
    probe_protocol: Optional[MediaProtocol] = Field(default=None, alias="ProbeProtocol")
    container: Optional[StrictStr] = Field(default=None, alias="Container")
    size: Optional[StrictInt] = Field(default=None, alias="Size")
    name: Optional[StrictStr] = Field(default=None, alias="Name")
    sort_name: Optional[StrictStr] = Field(default=None, alias="SortName")
    is_remote: Optional[StrictBool] = Field(default=None, description="Differentiate internet url vs local network", alias="IsRemote")
    has_mixed_protocols: Optional[StrictBool] = Field(default=None, alias="HasMixedProtocols")
    run_time_ticks: Optional[StrictInt] = Field(default=None, alias="RunTimeTicks")
    container_start_time_ticks: Optional[StrictInt] = Field(default=None, alias="ContainerStartTimeTicks")
    supports_transcoding: Optional[StrictBool] = Field(default=None, alias="SupportsTranscoding")
    trancode_live_start_index: Optional[StrictInt] = Field(default=None, alias="TrancodeLiveStartIndex")
    wall_clock_start: Optional[datetime] = Field(default=None, alias="WallClockStart")
    supports_direct_stream: Optional[StrictBool] = Field(default=None, alias="SupportsDirectStream")
    supports_direct_play: Optional[StrictBool] = Field(default=None, alias="SupportsDirectPlay")
    is_infinite_stream: Optional[StrictBool] = Field(default=None, alias="IsInfiniteStream")
    requires_opening: Optional[StrictBool] = Field(default=None, alias="RequiresOpening")
    open_token: Optional[StrictStr] = Field(default=None, alias="OpenToken")
    requires_closing: Optional[StrictBool] = Field(default=None, alias="RequiresClosing")
    live_stream_id: Optional[StrictStr] = Field(default=None, alias="LiveStreamId")
    buffer_ms: Optional[StrictInt] = Field(default=None, alias="BufferMs")
    requires_looping: Optional[StrictBool] = Field(default=None, alias="RequiresLooping")
    supports_probing: Optional[StrictBool] = Field(default=None, alias="SupportsProbing")
    video3_d_format: Optional[Video3DFormat] = Field(default=None, alias="Video3DFormat")
    media_streams: Optional[List[MediaStream]] = Field(default=None, alias="MediaStreams")
    formats: Optional[List[StrictStr]] = Field(default=None, alias="Formats")
    bitrate: Optional[StrictInt] = Field(default=None, alias="Bitrate")
    timestamp: Optional[TransportStreamTimestamp] = Field(default=None, alias="Timestamp")
    required_http_headers: Optional[Dict[str, StrictStr]] = Field(default=None, alias="RequiredHttpHeaders")
    direct_stream_url: Optional[StrictStr] = Field(default=None, alias="DirectStreamUrl")
    add_api_key_to_direct_stream_url: Optional[StrictBool] = Field(default=None, alias="AddApiKeyToDirectStreamUrl")
    transcoding_url: Optional[StrictStr] = Field(default=None, alias="TranscodingUrl")
    transcoding_sub_protocol: Optional[StrictStr] = Field(default=None, alias="TranscodingSubProtocol")
    transcoding_container: Optional[StrictStr] = Field(default=None, alias="TranscodingContainer")
    analyze_duration_ms: Optional[StrictInt] = Field(default=None, alias="AnalyzeDurationMs")
    read_at_native_framerate: Optional[StrictBool] = Field(default=None, alias="ReadAtNativeFramerate")
    default_audio_stream_index: Optional[StrictInt] = Field(default=None, alias="DefaultAudioStreamIndex")
    default_subtitle_stream_index: Optional[StrictInt] = Field(default=None, alias="DefaultSubtitleStreamIndex")
    item_id: Optional[StrictStr] = Field(default=None, description="Used only by our Windows app. Not used by Emby Server. The id of the item that this mediasource belongs to, if there is one Also used by Emby for Kodi", alias="ItemId")
    server_id: Optional[StrictStr] = Field(default=None, description="Used only by our Windows app. Not used by Emby Server.", alias="ServerId")
    __properties: ClassVar[List[str]] = ["Protocol", "Id", "Path", "EncoderPath", "EncoderProtocol", "Type", "ProbePath", "ProbeProtocol", "Container", "Size", "Name", "SortName", "IsRemote", "HasMixedProtocols", "RunTimeTicks", "ContainerStartTimeTicks", "SupportsTranscoding", "TrancodeLiveStartIndex", "WallClockStart", "SupportsDirectStream", "SupportsDirectPlay", "IsInfiniteStream", "RequiresOpening", "OpenToken", "RequiresClosing", "LiveStreamId", "BufferMs", "RequiresLooping", "SupportsProbing", "Video3DFormat", "MediaStreams", "Formats", "Bitrate", "Timestamp", "RequiredHttpHeaders", "DirectStreamUrl", "AddApiKeyToDirectStreamUrl", "TranscodingUrl", "TranscodingSubProtocol", "TranscodingContainer", "AnalyzeDurationMs", "ReadAtNativeFramerate", "DefaultAudioStreamIndex", "DefaultSubtitleStreamIndex", "ItemId", "ServerId"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of MediaSourceInfo from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in media_streams (list)
        _items = []
        if self.media_streams:
            for _item in self.media_streams:
                if _item:
                    _items.append(_item.to_dict())
            _dict['MediaStreams'] = _items
        # set to None if size (nullable) is None
        # and model_fields_set contains the field
        if self.size is None and "size" in self.model_fields_set:
            _dict['Size'] = None

        # set to None if run_time_ticks (nullable) is None
        # and model_fields_set contains the field
        if self.run_time_ticks is None and "run_time_ticks" in self.model_fields_set:
            _dict['RunTimeTicks'] = None

        # set to None if container_start_time_ticks (nullable) is None
        # and model_fields_set contains the field
        if self.container_start_time_ticks is None and "container_start_time_ticks" in self.model_fields_set:
            _dict['ContainerStartTimeTicks'] = None

        # set to None if trancode_live_start_index (nullable) is None
        # and model_fields_set contains the field
        if self.trancode_live_start_index is None and "trancode_live_start_index" in self.model_fields_set:
            _dict['TrancodeLiveStartIndex'] = None

        # set to None if wall_clock_start (nullable) is None
        # and model_fields_set contains the field
        if self.wall_clock_start is None and "wall_clock_start" in self.model_fields_set:
            _dict['WallClockStart'] = None

        # set to None if buffer_ms (nullable) is None
        # and model_fields_set contains the field
        if self.buffer_ms is None and "buffer_ms" in self.model_fields_set:
            _dict['BufferMs'] = None

        # set to None if bitrate (nullable) is None
        # and model_fields_set contains the field
        if self.bitrate is None and "bitrate" in self.model_fields_set:
            _dict['Bitrate'] = None

        # set to None if analyze_duration_ms (nullable) is None
        # and model_fields_set contains the field
        if self.analyze_duration_ms is None and "analyze_duration_ms" in self.model_fields_set:
            _dict['AnalyzeDurationMs'] = None

        # set to None if default_audio_stream_index (nullable) is None
        # and model_fields_set contains the field
        if self.default_audio_stream_index is None and "default_audio_stream_index" in self.model_fields_set:
            _dict['DefaultAudioStreamIndex'] = None

        # set to None if default_subtitle_stream_index (nullable) is None
        # and model_fields_set contains the field
        if self.default_subtitle_stream_index is None and "default_subtitle_stream_index" in self.model_fields_set:
            _dict['DefaultSubtitleStreamIndex'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of MediaSourceInfo from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "Protocol": obj.get("Protocol"),
            "Id": obj.get("Id"),
            "Path": obj.get("Path"),
            "EncoderPath": obj.get("EncoderPath"),
            "EncoderProtocol": obj.get("EncoderProtocol"),
            "Type": obj.get("Type"),
            "ProbePath": obj.get("ProbePath"),
            "ProbeProtocol": obj.get("ProbeProtocol"),
            "Container": obj.get("Container"),
            "Size": obj.get("Size"),
            "Name": obj.get("Name"),
            "SortName": obj.get("SortName"),
            "IsRemote": obj.get("IsRemote"),
            "HasMixedProtocols": obj.get("HasMixedProtocols"),
            "RunTimeTicks": obj.get("RunTimeTicks"),
            "ContainerStartTimeTicks": obj.get("ContainerStartTimeTicks"),
            "SupportsTranscoding": obj.get("SupportsTranscoding"),
            "TrancodeLiveStartIndex": obj.get("TrancodeLiveStartIndex"),
            "WallClockStart": obj.get("WallClockStart"),
            "SupportsDirectStream": obj.get("SupportsDirectStream"),
            "SupportsDirectPlay": obj.get("SupportsDirectPlay"),
            "IsInfiniteStream": obj.get("IsInfiniteStream"),
            "RequiresOpening": obj.get("RequiresOpening"),
            "OpenToken": obj.get("OpenToken"),
            "RequiresClosing": obj.get("RequiresClosing"),
            "LiveStreamId": obj.get("LiveStreamId"),
            "BufferMs": obj.get("BufferMs"),
            "RequiresLooping": obj.get("RequiresLooping"),
            "SupportsProbing": obj.get("SupportsProbing"),
            "Video3DFormat": obj.get("Video3DFormat"),
            "MediaStreams": [MediaStream.from_dict(_item) for _item in obj["MediaStreams"]] if obj.get("MediaStreams") is not None else None,
            "Formats": obj.get("Formats"),
            "Bitrate": obj.get("Bitrate"),
            "Timestamp": obj.get("Timestamp"),
            "RequiredHttpHeaders": obj.get("RequiredHttpHeaders"),
            "DirectStreamUrl": obj.get("DirectStreamUrl"),
            "AddApiKeyToDirectStreamUrl": obj.get("AddApiKeyToDirectStreamUrl"),
            "TranscodingUrl": obj.get("TranscodingUrl"),
            "TranscodingSubProtocol": obj.get("TranscodingSubProtocol"),
            "TranscodingContainer": obj.get("TranscodingContainer"),
            "AnalyzeDurationMs": obj.get("AnalyzeDurationMs"),
            "ReadAtNativeFramerate": obj.get("ReadAtNativeFramerate"),
            "DefaultAudioStreamIndex": obj.get("DefaultAudioStreamIndex"),
            "DefaultSubtitleStreamIndex": obj.get("DefaultSubtitleStreamIndex"),
            "ItemId": obj.get("ItemId"),
            "ServerId": obj.get("ServerId")
        })
        return _obj


