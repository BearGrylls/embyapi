# coding: utf-8

"""
    Emby Server REST API

    Explore the Emby Server API

    The version of the OpenAPI document: 4.8.7.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictFloat, StrictInt, StrictStr
from typing import Optional, Union
from typing_extensions import Annotated
from embyapi.models.query_result_base_item_dto import QueryResultBaseItemDto

from embyapi.api_client import ApiClient, RequestSerialized
from embyapi.api_response import ApiResponse
from embyapi.rest import RESTResponseType


class TrailersServiceApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def get_trailers(
        self,
        artist_type: Annotated[Optional[StrictStr], Field(description="Artist or AlbumArtist")] = None,
        max_official_rating: Annotated[Optional[StrictStr], Field(description="Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).")] = None,
        has_theme_song: Annotated[Optional[StrictBool], Field(description="Optional filter by items with theme songs.")] = None,
        has_theme_video: Annotated[Optional[StrictBool], Field(description="Optional filter by items with theme videos.")] = None,
        has_subtitles: Annotated[Optional[StrictBool], Field(description="Optional filter by items with subtitles.")] = None,
        has_special_feature: Annotated[Optional[StrictBool], Field(description="Optional filter by items with special features.")] = None,
        has_trailer: Annotated[Optional[StrictBool], Field(description="Optional filter by items with trailers.")] = None,
        adjacent_to: Annotated[Optional[StrictStr], Field(description="Optional. Return items that are siblings of a supplied item.")] = None,
        min_index_number: Annotated[Optional[StrictInt], Field(description="Optional filter by minimum index number.")] = None,
        min_start_date: Annotated[Optional[StrictStr], Field(description="Optional. The minimum premiere date. Format = ISO")] = None,
        max_start_date: Annotated[Optional[StrictStr], Field(description="Optional. The maximum premiere date. Format = ISO")] = None,
        min_end_date: Annotated[Optional[StrictStr], Field(description="Optional. The minimum premiere date. Format = ISO")] = None,
        max_end_date: Annotated[Optional[StrictStr], Field(description="Optional. The maximum premiere date. Format = ISO")] = None,
        min_players: Annotated[Optional[StrictInt], Field(description="Optional filter by minimum number of game players.")] = None,
        max_players: Annotated[Optional[StrictInt], Field(description="Optional filter by maximum number of game players.")] = None,
        parent_index_number: Annotated[Optional[StrictInt], Field(description="Optional filter by parent index number.")] = None,
        has_parental_rating: Annotated[Optional[StrictBool], Field(description="Optional filter by items that have or do not have a parental rating")] = None,
        is_hd: Annotated[Optional[StrictBool], Field(description="Optional filter by items that are HD or not.")] = None,
        is_unaired: Annotated[Optional[StrictBool], Field(description="Optional filter by items that are unaired episodes or not.")] = None,
        min_community_rating: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Optional filter by minimum community rating.")] = None,
        min_critic_rating: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Optional filter by minimum critic rating.")] = None,
        aired_during_season: Annotated[Optional[StrictInt], Field(description="Gets all episodes that aired during a season, including specials.")] = None,
        min_premiere_date: Annotated[Optional[StrictStr], Field(description="Optional. The minimum premiere date. Format = ISO")] = None,
        min_date_last_saved: Annotated[Optional[StrictStr], Field(description="Optional. The minimum premiere date. Format = ISO")] = None,
        min_date_last_saved_for_user: Annotated[Optional[StrictStr], Field(description="Optional. The minimum premiere date. Format = ISO")] = None,
        max_premiere_date: Annotated[Optional[StrictStr], Field(description="Optional. The maximum premiere date. Format = ISO")] = None,
        has_overview: Annotated[Optional[StrictBool], Field(description="Optional filter by items that have an overview or not.")] = None,
        has_imdb_id: Annotated[Optional[StrictBool], Field(description="Optional filter by items that have an imdb id or not.")] = None,
        has_tmdb_id: Annotated[Optional[StrictBool], Field(description="Optional filter by items that have a tmdb id or not.")] = None,
        has_tvdb_id: Annotated[Optional[StrictBool], Field(description="Optional filter by items that have a tvdb id or not.")] = None,
        exclude_item_ids: Annotated[Optional[StrictStr], Field(description="Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.")] = None,
        start_index: Annotated[Optional[StrictInt], Field(description="Optional. The record index to start at. All items with a lower index will be dropped from the results.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Optional. The maximum number of records to return")] = None,
        recursive: Annotated[Optional[StrictBool], Field(description="When searching within folders, this determines whether or not the search will be recursive. true/false")] = None,
        search_term: Annotated[Optional[StrictStr], Field(description="Enter a search term to perform a search request")] = None,
        sort_order: Annotated[Optional[StrictStr], Field(description="Sort Order - Ascending,Descending")] = None,
        parent_id: Annotated[Optional[StrictStr], Field(description="Specify this to localize the search to a specific item or folder. Omit to use the root")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines")] = None,
        exclude_item_types: Annotated[Optional[StrictStr], Field(description="Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.")] = None,
        include_item_types: Annotated[Optional[StrictStr], Field(description="Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.")] = None,
        any_provider_id_equals: Annotated[Optional[StrictStr], Field(description="Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.")] = None,
        filters: Annotated[Optional[StrictStr], Field(description="Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes")] = None,
        is_favorite: Annotated[Optional[StrictBool], Field(description="Optional filter by items that are marked as favorite, or not.")] = None,
        is_movie: Annotated[Optional[StrictBool], Field(description="Optional filter for movies.")] = None,
        is_series: Annotated[Optional[StrictBool], Field(description="Optional filter for series.")] = None,
        is_folder: Annotated[Optional[StrictBool], Field(description="Optional filter for folders.")] = None,
        is_news: Annotated[Optional[StrictBool], Field(description="Optional filter for news.")] = None,
        is_kids: Annotated[Optional[StrictBool], Field(description="Optional filter for kids.")] = None,
        is_sports: Annotated[Optional[StrictBool], Field(description="Optional filter for sports.")] = None,
        is_new: Annotated[Optional[StrictBool], Field(description="Optional filter for IsNew.")] = None,
        is_premiere: Annotated[Optional[StrictBool], Field(description="Optional filter for IsPremiere.")] = None,
        is_new_or_premiere: Annotated[Optional[StrictBool], Field(description="Optional filter for IsNewOrPremiere.")] = None,
        is_repeat: Annotated[Optional[StrictBool], Field(description="Optional filter for IsRepeat.")] = None,
        project_to_media: Annotated[Optional[StrictBool], Field(description="ProjectToMedia")] = None,
        media_types: Annotated[Optional[StrictStr], Field(description="Optional filter by MediaType. Allows multiple, comma delimited.")] = None,
        image_types: Annotated[Optional[StrictStr], Field(description="Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.")] = None,
        sort_by: Annotated[Optional[StrictStr], Field(description="Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime")] = None,
        is_played: Annotated[Optional[StrictBool], Field(description="Optional filter by items that are played, or not.")] = None,
        genres: Annotated[Optional[StrictStr], Field(description="Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.")] = None,
        official_ratings: Annotated[Optional[StrictStr], Field(description="Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.")] = None,
        tags: Annotated[Optional[StrictStr], Field(description="Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.")] = None,
        exclude_tags: Annotated[Optional[StrictStr], Field(description="Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.")] = None,
        years: Annotated[Optional[StrictStr], Field(description="Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.")] = None,
        enable_images: Annotated[Optional[StrictBool], Field(description="Optional, include image information in output")] = None,
        enable_user_data: Annotated[Optional[StrictBool], Field(description="Optional, include user data")] = None,
        image_type_limit: Annotated[Optional[StrictInt], Field(description="Optional, the max number of images to return, per image type")] = None,
        enable_image_types: Annotated[Optional[StrictStr], Field(description="Optional. The image types to include in the output.")] = None,
        person: Annotated[Optional[StrictStr], Field(description="Optional. If specified, results will be filtered to include only those containing the specified person.")] = None,
        person_ids: Annotated[Optional[StrictStr], Field(description="Optional. If specified, results will be filtered to include only those containing the specified person.")] = None,
        person_types: Annotated[Optional[StrictStr], Field(description="Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited")] = None,
        studios: Annotated[Optional[StrictStr], Field(description="Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.")] = None,
        studio_ids: Annotated[Optional[StrictStr], Field(description="Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.")] = None,
        artists: Annotated[Optional[StrictStr], Field(description="Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.")] = None,
        artist_ids: Annotated[Optional[StrictStr], Field(description="Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.")] = None,
        albums: Annotated[Optional[StrictStr], Field(description="Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.")] = None,
        ids: Annotated[Optional[StrictStr], Field(description="Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.")] = None,
        video_types: Annotated[Optional[StrictStr], Field(description="Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.")] = None,
        containers: Annotated[Optional[StrictStr], Field(description="Optional filter by Container. Allows multiple, comma delimeted.")] = None,
        audio_codecs: Annotated[Optional[StrictStr], Field(description="Optional filter by AudioCodec. Allows multiple, comma delimeted.")] = None,
        audio_layouts: Annotated[Optional[StrictStr], Field(description="Optional filter by AudioLayout. Allows multiple, comma delimeted.")] = None,
        video_codecs: Annotated[Optional[StrictStr], Field(description="Optional filter by VideoCodec. Allows multiple, comma delimeted.")] = None,
        extended_video_types: Annotated[Optional[StrictStr], Field(description="Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.")] = None,
        subtitle_codecs: Annotated[Optional[StrictStr], Field(description="Optional filter by SubtitleCodec. Allows multiple, comma delimeted.")] = None,
        path: Annotated[Optional[StrictStr], Field(description="Optional filter by Path.")] = None,
        user_id: Annotated[Optional[StrictStr], Field(description="User Id")] = None,
        min_official_rating: Annotated[Optional[StrictStr], Field(description="Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).")] = None,
        is_locked: Annotated[Optional[StrictBool], Field(description="Optional filter by items that are locked.")] = None,
        is_place_holder: Annotated[Optional[StrictBool], Field(description="Optional filter by items that are placeholders")] = None,
        has_official_rating: Annotated[Optional[StrictBool], Field(description="Optional filter by items that have official ratings")] = None,
        group_items_into_collections: Annotated[Optional[StrictBool], Field(description="Whether or not to hide items behind their boxsets.")] = None,
        is3_d: Annotated[Optional[StrictBool], Field(description="Optional filter by items that are 3D, or not.")] = None,
        series_status: Annotated[Optional[StrictStr], Field(description="Optional filter by Series Status. Allows multiple, comma delimeted.")] = None,
        name_starts_with_or_greater: Annotated[Optional[StrictStr], Field(description="Optional filter by items whose name is sorted equally or greater than a given input string.")] = None,
        artist_starts_with_or_greater: Annotated[Optional[StrictStr], Field(description="Optional filter by items whose name is sorted equally or greater than a given input string.")] = None,
        album_artist_starts_with_or_greater: Annotated[Optional[StrictStr], Field(description="Optional filter by items whose name is sorted equally or greater than a given input string.")] = None,
        name_starts_with: Annotated[Optional[StrictStr], Field(description="Optional filter by items whose name is sorted equally than a given input string.")] = None,
        name_less_than: Annotated[Optional[StrictStr], Field(description="Optional filter by items whose name is equally or lesser than a given input string.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> QueryResultBaseItemDto:
        """Finds movies and trailers similar to a given trailer.

        Requires authentication as user

        :param artist_type: Artist or AlbumArtist
        :type artist_type: str
        :param max_official_rating: Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
        :type max_official_rating: str
        :param has_theme_song: Optional filter by items with theme songs.
        :type has_theme_song: bool
        :param has_theme_video: Optional filter by items with theme videos.
        :type has_theme_video: bool
        :param has_subtitles: Optional filter by items with subtitles.
        :type has_subtitles: bool
        :param has_special_feature: Optional filter by items with special features.
        :type has_special_feature: bool
        :param has_trailer: Optional filter by items with trailers.
        :type has_trailer: bool
        :param adjacent_to: Optional. Return items that are siblings of a supplied item.
        :type adjacent_to: str
        :param min_index_number: Optional filter by minimum index number.
        :type min_index_number: int
        :param min_start_date: Optional. The minimum premiere date. Format = ISO
        :type min_start_date: str
        :param max_start_date: Optional. The maximum premiere date. Format = ISO
        :type max_start_date: str
        :param min_end_date: Optional. The minimum premiere date. Format = ISO
        :type min_end_date: str
        :param max_end_date: Optional. The maximum premiere date. Format = ISO
        :type max_end_date: str
        :param min_players: Optional filter by minimum number of game players.
        :type min_players: int
        :param max_players: Optional filter by maximum number of game players.
        :type max_players: int
        :param parent_index_number: Optional filter by parent index number.
        :type parent_index_number: int
        :param has_parental_rating: Optional filter by items that have or do not have a parental rating
        :type has_parental_rating: bool
        :param is_hd: Optional filter by items that are HD or not.
        :type is_hd: bool
        :param is_unaired: Optional filter by items that are unaired episodes or not.
        :type is_unaired: bool
        :param min_community_rating: Optional filter by minimum community rating.
        :type min_community_rating: float
        :param min_critic_rating: Optional filter by minimum critic rating.
        :type min_critic_rating: float
        :param aired_during_season: Gets all episodes that aired during a season, including specials.
        :type aired_during_season: int
        :param min_premiere_date: Optional. The minimum premiere date. Format = ISO
        :type min_premiere_date: str
        :param min_date_last_saved: Optional. The minimum premiere date. Format = ISO
        :type min_date_last_saved: str
        :param min_date_last_saved_for_user: Optional. The minimum premiere date. Format = ISO
        :type min_date_last_saved_for_user: str
        :param max_premiere_date: Optional. The maximum premiere date. Format = ISO
        :type max_premiere_date: str
        :param has_overview: Optional filter by items that have an overview or not.
        :type has_overview: bool
        :param has_imdb_id: Optional filter by items that have an imdb id or not.
        :type has_imdb_id: bool
        :param has_tmdb_id: Optional filter by items that have a tmdb id or not.
        :type has_tmdb_id: bool
        :param has_tvdb_id: Optional filter by items that have a tvdb id or not.
        :type has_tvdb_id: bool
        :param exclude_item_ids: Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
        :type exclude_item_ids: str
        :param start_index: Optional. The record index to start at. All items with a lower index will be dropped from the results.
        :type start_index: int
        :param limit: Optional. The maximum number of records to return
        :type limit: int
        :param recursive: When searching within folders, this determines whether or not the search will be recursive. true/false
        :type recursive: bool
        :param search_term: Enter a search term to perform a search request
        :type search_term: str
        :param sort_order: Sort Order - Ascending,Descending
        :type sort_order: str
        :param parent_id: Specify this to localize the search to a specific item or folder. Omit to use the root
        :type parent_id: str
        :param fields: Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
        :type fields: str
        :param exclude_item_types: Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
        :type exclude_item_types: str
        :param include_item_types: Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
        :type include_item_types: str
        :param any_provider_id_equals: Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
        :type any_provider_id_equals: str
        :param filters: Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
        :type filters: str
        :param is_favorite: Optional filter by items that are marked as favorite, or not.
        :type is_favorite: bool
        :param is_movie: Optional filter for movies.
        :type is_movie: bool
        :param is_series: Optional filter for series.
        :type is_series: bool
        :param is_folder: Optional filter for folders.
        :type is_folder: bool
        :param is_news: Optional filter for news.
        :type is_news: bool
        :param is_kids: Optional filter for kids.
        :type is_kids: bool
        :param is_sports: Optional filter for sports.
        :type is_sports: bool
        :param is_new: Optional filter for IsNew.
        :type is_new: bool
        :param is_premiere: Optional filter for IsPremiere.
        :type is_premiere: bool
        :param is_new_or_premiere: Optional filter for IsNewOrPremiere.
        :type is_new_or_premiere: bool
        :param is_repeat: Optional filter for IsRepeat.
        :type is_repeat: bool
        :param project_to_media: ProjectToMedia
        :type project_to_media: bool
        :param media_types: Optional filter by MediaType. Allows multiple, comma delimited.
        :type media_types: str
        :param image_types: Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
        :type image_types: str
        :param sort_by: Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
        :type sort_by: str
        :param is_played: Optional filter by items that are played, or not.
        :type is_played: bool
        :param genres: Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
        :type genres: str
        :param official_ratings: Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
        :type official_ratings: str
        :param tags: Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
        :type tags: str
        :param exclude_tags: Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
        :type exclude_tags: str
        :param years: Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
        :type years: str
        :param enable_images: Optional, include image information in output
        :type enable_images: bool
        :param enable_user_data: Optional, include user data
        :type enable_user_data: bool
        :param image_type_limit: Optional, the max number of images to return, per image type
        :type image_type_limit: int
        :param enable_image_types: Optional. The image types to include in the output.
        :type enable_image_types: str
        :param person: Optional. If specified, results will be filtered to include only those containing the specified person.
        :type person: str
        :param person_ids: Optional. If specified, results will be filtered to include only those containing the specified person.
        :type person_ids: str
        :param person_types: Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
        :type person_types: str
        :param studios: Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
        :type studios: str
        :param studio_ids: Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
        :type studio_ids: str
        :param artists: Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
        :type artists: str
        :param artist_ids: Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
        :type artist_ids: str
        :param albums: Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
        :type albums: str
        :param ids: Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
        :type ids: str
        :param video_types: Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
        :type video_types: str
        :param containers: Optional filter by Container. Allows multiple, comma delimeted.
        :type containers: str
        :param audio_codecs: Optional filter by AudioCodec. Allows multiple, comma delimeted.
        :type audio_codecs: str
        :param audio_layouts: Optional filter by AudioLayout. Allows multiple, comma delimeted.
        :type audio_layouts: str
        :param video_codecs: Optional filter by VideoCodec. Allows multiple, comma delimeted.
        :type video_codecs: str
        :param extended_video_types: Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
        :type extended_video_types: str
        :param subtitle_codecs: Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
        :type subtitle_codecs: str
        :param path: Optional filter by Path.
        :type path: str
        :param user_id: User Id
        :type user_id: str
        :param min_official_rating: Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
        :type min_official_rating: str
        :param is_locked: Optional filter by items that are locked.
        :type is_locked: bool
        :param is_place_holder: Optional filter by items that are placeholders
        :type is_place_holder: bool
        :param has_official_rating: Optional filter by items that have official ratings
        :type has_official_rating: bool
        :param group_items_into_collections: Whether or not to hide items behind their boxsets.
        :type group_items_into_collections: bool
        :param is3_d: Optional filter by items that are 3D, or not.
        :type is3_d: bool
        :param series_status: Optional filter by Series Status. Allows multiple, comma delimeted.
        :type series_status: str
        :param name_starts_with_or_greater: Optional filter by items whose name is sorted equally or greater than a given input string.
        :type name_starts_with_or_greater: str
        :param artist_starts_with_or_greater: Optional filter by items whose name is sorted equally or greater than a given input string.
        :type artist_starts_with_or_greater: str
        :param album_artist_starts_with_or_greater: Optional filter by items whose name is sorted equally or greater than a given input string.
        :type album_artist_starts_with_or_greater: str
        :param name_starts_with: Optional filter by items whose name is sorted equally than a given input string.
        :type name_starts_with: str
        :param name_less_than: Optional filter by items whose name is equally or lesser than a given input string.
        :type name_less_than: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_trailers_serialize(
            artist_type=artist_type,
            max_official_rating=max_official_rating,
            has_theme_song=has_theme_song,
            has_theme_video=has_theme_video,
            has_subtitles=has_subtitles,
            has_special_feature=has_special_feature,
            has_trailer=has_trailer,
            adjacent_to=adjacent_to,
            min_index_number=min_index_number,
            min_start_date=min_start_date,
            max_start_date=max_start_date,
            min_end_date=min_end_date,
            max_end_date=max_end_date,
            min_players=min_players,
            max_players=max_players,
            parent_index_number=parent_index_number,
            has_parental_rating=has_parental_rating,
            is_hd=is_hd,
            is_unaired=is_unaired,
            min_community_rating=min_community_rating,
            min_critic_rating=min_critic_rating,
            aired_during_season=aired_during_season,
            min_premiere_date=min_premiere_date,
            min_date_last_saved=min_date_last_saved,
            min_date_last_saved_for_user=min_date_last_saved_for_user,
            max_premiere_date=max_premiere_date,
            has_overview=has_overview,
            has_imdb_id=has_imdb_id,
            has_tmdb_id=has_tmdb_id,
            has_tvdb_id=has_tvdb_id,
            exclude_item_ids=exclude_item_ids,
            start_index=start_index,
            limit=limit,
            recursive=recursive,
            search_term=search_term,
            sort_order=sort_order,
            parent_id=parent_id,
            fields=fields,
            exclude_item_types=exclude_item_types,
            include_item_types=include_item_types,
            any_provider_id_equals=any_provider_id_equals,
            filters=filters,
            is_favorite=is_favorite,
            is_movie=is_movie,
            is_series=is_series,
            is_folder=is_folder,
            is_news=is_news,
            is_kids=is_kids,
            is_sports=is_sports,
            is_new=is_new,
            is_premiere=is_premiere,
            is_new_or_premiere=is_new_or_premiere,
            is_repeat=is_repeat,
            project_to_media=project_to_media,
            media_types=media_types,
            image_types=image_types,
            sort_by=sort_by,
            is_played=is_played,
            genres=genres,
            official_ratings=official_ratings,
            tags=tags,
            exclude_tags=exclude_tags,
            years=years,
            enable_images=enable_images,
            enable_user_data=enable_user_data,
            image_type_limit=image_type_limit,
            enable_image_types=enable_image_types,
            person=person,
            person_ids=person_ids,
            person_types=person_types,
            studios=studios,
            studio_ids=studio_ids,
            artists=artists,
            artist_ids=artist_ids,
            albums=albums,
            ids=ids,
            video_types=video_types,
            containers=containers,
            audio_codecs=audio_codecs,
            audio_layouts=audio_layouts,
            video_codecs=video_codecs,
            extended_video_types=extended_video_types,
            subtitle_codecs=subtitle_codecs,
            path=path,
            user_id=user_id,
            min_official_rating=min_official_rating,
            is_locked=is_locked,
            is_place_holder=is_place_holder,
            has_official_rating=has_official_rating,
            group_items_into_collections=group_items_into_collections,
            is3_d=is3_d,
            series_status=series_status,
            name_starts_with_or_greater=name_starts_with_or_greater,
            artist_starts_with_or_greater=artist_starts_with_or_greater,
            album_artist_starts_with_or_greater=album_artist_starts_with_or_greater,
            name_starts_with=name_starts_with,
            name_less_than=name_less_than,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "QueryResultBaseItemDto",
            '400': None,
            '401': None,
            '403': None,
            '404': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_trailers_with_http_info(
        self,
        artist_type: Annotated[Optional[StrictStr], Field(description="Artist or AlbumArtist")] = None,
        max_official_rating: Annotated[Optional[StrictStr], Field(description="Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).")] = None,
        has_theme_song: Annotated[Optional[StrictBool], Field(description="Optional filter by items with theme songs.")] = None,
        has_theme_video: Annotated[Optional[StrictBool], Field(description="Optional filter by items with theme videos.")] = None,
        has_subtitles: Annotated[Optional[StrictBool], Field(description="Optional filter by items with subtitles.")] = None,
        has_special_feature: Annotated[Optional[StrictBool], Field(description="Optional filter by items with special features.")] = None,
        has_trailer: Annotated[Optional[StrictBool], Field(description="Optional filter by items with trailers.")] = None,
        adjacent_to: Annotated[Optional[StrictStr], Field(description="Optional. Return items that are siblings of a supplied item.")] = None,
        min_index_number: Annotated[Optional[StrictInt], Field(description="Optional filter by minimum index number.")] = None,
        min_start_date: Annotated[Optional[StrictStr], Field(description="Optional. The minimum premiere date. Format = ISO")] = None,
        max_start_date: Annotated[Optional[StrictStr], Field(description="Optional. The maximum premiere date. Format = ISO")] = None,
        min_end_date: Annotated[Optional[StrictStr], Field(description="Optional. The minimum premiere date. Format = ISO")] = None,
        max_end_date: Annotated[Optional[StrictStr], Field(description="Optional. The maximum premiere date. Format = ISO")] = None,
        min_players: Annotated[Optional[StrictInt], Field(description="Optional filter by minimum number of game players.")] = None,
        max_players: Annotated[Optional[StrictInt], Field(description="Optional filter by maximum number of game players.")] = None,
        parent_index_number: Annotated[Optional[StrictInt], Field(description="Optional filter by parent index number.")] = None,
        has_parental_rating: Annotated[Optional[StrictBool], Field(description="Optional filter by items that have or do not have a parental rating")] = None,
        is_hd: Annotated[Optional[StrictBool], Field(description="Optional filter by items that are HD or not.")] = None,
        is_unaired: Annotated[Optional[StrictBool], Field(description="Optional filter by items that are unaired episodes or not.")] = None,
        min_community_rating: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Optional filter by minimum community rating.")] = None,
        min_critic_rating: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Optional filter by minimum critic rating.")] = None,
        aired_during_season: Annotated[Optional[StrictInt], Field(description="Gets all episodes that aired during a season, including specials.")] = None,
        min_premiere_date: Annotated[Optional[StrictStr], Field(description="Optional. The minimum premiere date. Format = ISO")] = None,
        min_date_last_saved: Annotated[Optional[StrictStr], Field(description="Optional. The minimum premiere date. Format = ISO")] = None,
        min_date_last_saved_for_user: Annotated[Optional[StrictStr], Field(description="Optional. The minimum premiere date. Format = ISO")] = None,
        max_premiere_date: Annotated[Optional[StrictStr], Field(description="Optional. The maximum premiere date. Format = ISO")] = None,
        has_overview: Annotated[Optional[StrictBool], Field(description="Optional filter by items that have an overview or not.")] = None,
        has_imdb_id: Annotated[Optional[StrictBool], Field(description="Optional filter by items that have an imdb id or not.")] = None,
        has_tmdb_id: Annotated[Optional[StrictBool], Field(description="Optional filter by items that have a tmdb id or not.")] = None,
        has_tvdb_id: Annotated[Optional[StrictBool], Field(description="Optional filter by items that have a tvdb id or not.")] = None,
        exclude_item_ids: Annotated[Optional[StrictStr], Field(description="Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.")] = None,
        start_index: Annotated[Optional[StrictInt], Field(description="Optional. The record index to start at. All items with a lower index will be dropped from the results.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Optional. The maximum number of records to return")] = None,
        recursive: Annotated[Optional[StrictBool], Field(description="When searching within folders, this determines whether or not the search will be recursive. true/false")] = None,
        search_term: Annotated[Optional[StrictStr], Field(description="Enter a search term to perform a search request")] = None,
        sort_order: Annotated[Optional[StrictStr], Field(description="Sort Order - Ascending,Descending")] = None,
        parent_id: Annotated[Optional[StrictStr], Field(description="Specify this to localize the search to a specific item or folder. Omit to use the root")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines")] = None,
        exclude_item_types: Annotated[Optional[StrictStr], Field(description="Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.")] = None,
        include_item_types: Annotated[Optional[StrictStr], Field(description="Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.")] = None,
        any_provider_id_equals: Annotated[Optional[StrictStr], Field(description="Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.")] = None,
        filters: Annotated[Optional[StrictStr], Field(description="Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes")] = None,
        is_favorite: Annotated[Optional[StrictBool], Field(description="Optional filter by items that are marked as favorite, or not.")] = None,
        is_movie: Annotated[Optional[StrictBool], Field(description="Optional filter for movies.")] = None,
        is_series: Annotated[Optional[StrictBool], Field(description="Optional filter for series.")] = None,
        is_folder: Annotated[Optional[StrictBool], Field(description="Optional filter for folders.")] = None,
        is_news: Annotated[Optional[StrictBool], Field(description="Optional filter for news.")] = None,
        is_kids: Annotated[Optional[StrictBool], Field(description="Optional filter for kids.")] = None,
        is_sports: Annotated[Optional[StrictBool], Field(description="Optional filter for sports.")] = None,
        is_new: Annotated[Optional[StrictBool], Field(description="Optional filter for IsNew.")] = None,
        is_premiere: Annotated[Optional[StrictBool], Field(description="Optional filter for IsPremiere.")] = None,
        is_new_or_premiere: Annotated[Optional[StrictBool], Field(description="Optional filter for IsNewOrPremiere.")] = None,
        is_repeat: Annotated[Optional[StrictBool], Field(description="Optional filter for IsRepeat.")] = None,
        project_to_media: Annotated[Optional[StrictBool], Field(description="ProjectToMedia")] = None,
        media_types: Annotated[Optional[StrictStr], Field(description="Optional filter by MediaType. Allows multiple, comma delimited.")] = None,
        image_types: Annotated[Optional[StrictStr], Field(description="Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.")] = None,
        sort_by: Annotated[Optional[StrictStr], Field(description="Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime")] = None,
        is_played: Annotated[Optional[StrictBool], Field(description="Optional filter by items that are played, or not.")] = None,
        genres: Annotated[Optional[StrictStr], Field(description="Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.")] = None,
        official_ratings: Annotated[Optional[StrictStr], Field(description="Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.")] = None,
        tags: Annotated[Optional[StrictStr], Field(description="Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.")] = None,
        exclude_tags: Annotated[Optional[StrictStr], Field(description="Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.")] = None,
        years: Annotated[Optional[StrictStr], Field(description="Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.")] = None,
        enable_images: Annotated[Optional[StrictBool], Field(description="Optional, include image information in output")] = None,
        enable_user_data: Annotated[Optional[StrictBool], Field(description="Optional, include user data")] = None,
        image_type_limit: Annotated[Optional[StrictInt], Field(description="Optional, the max number of images to return, per image type")] = None,
        enable_image_types: Annotated[Optional[StrictStr], Field(description="Optional. The image types to include in the output.")] = None,
        person: Annotated[Optional[StrictStr], Field(description="Optional. If specified, results will be filtered to include only those containing the specified person.")] = None,
        person_ids: Annotated[Optional[StrictStr], Field(description="Optional. If specified, results will be filtered to include only those containing the specified person.")] = None,
        person_types: Annotated[Optional[StrictStr], Field(description="Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited")] = None,
        studios: Annotated[Optional[StrictStr], Field(description="Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.")] = None,
        studio_ids: Annotated[Optional[StrictStr], Field(description="Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.")] = None,
        artists: Annotated[Optional[StrictStr], Field(description="Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.")] = None,
        artist_ids: Annotated[Optional[StrictStr], Field(description="Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.")] = None,
        albums: Annotated[Optional[StrictStr], Field(description="Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.")] = None,
        ids: Annotated[Optional[StrictStr], Field(description="Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.")] = None,
        video_types: Annotated[Optional[StrictStr], Field(description="Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.")] = None,
        containers: Annotated[Optional[StrictStr], Field(description="Optional filter by Container. Allows multiple, comma delimeted.")] = None,
        audio_codecs: Annotated[Optional[StrictStr], Field(description="Optional filter by AudioCodec. Allows multiple, comma delimeted.")] = None,
        audio_layouts: Annotated[Optional[StrictStr], Field(description="Optional filter by AudioLayout. Allows multiple, comma delimeted.")] = None,
        video_codecs: Annotated[Optional[StrictStr], Field(description="Optional filter by VideoCodec. Allows multiple, comma delimeted.")] = None,
        extended_video_types: Annotated[Optional[StrictStr], Field(description="Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.")] = None,
        subtitle_codecs: Annotated[Optional[StrictStr], Field(description="Optional filter by SubtitleCodec. Allows multiple, comma delimeted.")] = None,
        path: Annotated[Optional[StrictStr], Field(description="Optional filter by Path.")] = None,
        user_id: Annotated[Optional[StrictStr], Field(description="User Id")] = None,
        min_official_rating: Annotated[Optional[StrictStr], Field(description="Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).")] = None,
        is_locked: Annotated[Optional[StrictBool], Field(description="Optional filter by items that are locked.")] = None,
        is_place_holder: Annotated[Optional[StrictBool], Field(description="Optional filter by items that are placeholders")] = None,
        has_official_rating: Annotated[Optional[StrictBool], Field(description="Optional filter by items that have official ratings")] = None,
        group_items_into_collections: Annotated[Optional[StrictBool], Field(description="Whether or not to hide items behind their boxsets.")] = None,
        is3_d: Annotated[Optional[StrictBool], Field(description="Optional filter by items that are 3D, or not.")] = None,
        series_status: Annotated[Optional[StrictStr], Field(description="Optional filter by Series Status. Allows multiple, comma delimeted.")] = None,
        name_starts_with_or_greater: Annotated[Optional[StrictStr], Field(description="Optional filter by items whose name is sorted equally or greater than a given input string.")] = None,
        artist_starts_with_or_greater: Annotated[Optional[StrictStr], Field(description="Optional filter by items whose name is sorted equally or greater than a given input string.")] = None,
        album_artist_starts_with_or_greater: Annotated[Optional[StrictStr], Field(description="Optional filter by items whose name is sorted equally or greater than a given input string.")] = None,
        name_starts_with: Annotated[Optional[StrictStr], Field(description="Optional filter by items whose name is sorted equally than a given input string.")] = None,
        name_less_than: Annotated[Optional[StrictStr], Field(description="Optional filter by items whose name is equally or lesser than a given input string.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[QueryResultBaseItemDto]:
        """Finds movies and trailers similar to a given trailer.

        Requires authentication as user

        :param artist_type: Artist or AlbumArtist
        :type artist_type: str
        :param max_official_rating: Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
        :type max_official_rating: str
        :param has_theme_song: Optional filter by items with theme songs.
        :type has_theme_song: bool
        :param has_theme_video: Optional filter by items with theme videos.
        :type has_theme_video: bool
        :param has_subtitles: Optional filter by items with subtitles.
        :type has_subtitles: bool
        :param has_special_feature: Optional filter by items with special features.
        :type has_special_feature: bool
        :param has_trailer: Optional filter by items with trailers.
        :type has_trailer: bool
        :param adjacent_to: Optional. Return items that are siblings of a supplied item.
        :type adjacent_to: str
        :param min_index_number: Optional filter by minimum index number.
        :type min_index_number: int
        :param min_start_date: Optional. The minimum premiere date. Format = ISO
        :type min_start_date: str
        :param max_start_date: Optional. The maximum premiere date. Format = ISO
        :type max_start_date: str
        :param min_end_date: Optional. The minimum premiere date. Format = ISO
        :type min_end_date: str
        :param max_end_date: Optional. The maximum premiere date. Format = ISO
        :type max_end_date: str
        :param min_players: Optional filter by minimum number of game players.
        :type min_players: int
        :param max_players: Optional filter by maximum number of game players.
        :type max_players: int
        :param parent_index_number: Optional filter by parent index number.
        :type parent_index_number: int
        :param has_parental_rating: Optional filter by items that have or do not have a parental rating
        :type has_parental_rating: bool
        :param is_hd: Optional filter by items that are HD or not.
        :type is_hd: bool
        :param is_unaired: Optional filter by items that are unaired episodes or not.
        :type is_unaired: bool
        :param min_community_rating: Optional filter by minimum community rating.
        :type min_community_rating: float
        :param min_critic_rating: Optional filter by minimum critic rating.
        :type min_critic_rating: float
        :param aired_during_season: Gets all episodes that aired during a season, including specials.
        :type aired_during_season: int
        :param min_premiere_date: Optional. The minimum premiere date. Format = ISO
        :type min_premiere_date: str
        :param min_date_last_saved: Optional. The minimum premiere date. Format = ISO
        :type min_date_last_saved: str
        :param min_date_last_saved_for_user: Optional. The minimum premiere date. Format = ISO
        :type min_date_last_saved_for_user: str
        :param max_premiere_date: Optional. The maximum premiere date. Format = ISO
        :type max_premiere_date: str
        :param has_overview: Optional filter by items that have an overview or not.
        :type has_overview: bool
        :param has_imdb_id: Optional filter by items that have an imdb id or not.
        :type has_imdb_id: bool
        :param has_tmdb_id: Optional filter by items that have a tmdb id or not.
        :type has_tmdb_id: bool
        :param has_tvdb_id: Optional filter by items that have a tvdb id or not.
        :type has_tvdb_id: bool
        :param exclude_item_ids: Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
        :type exclude_item_ids: str
        :param start_index: Optional. The record index to start at. All items with a lower index will be dropped from the results.
        :type start_index: int
        :param limit: Optional. The maximum number of records to return
        :type limit: int
        :param recursive: When searching within folders, this determines whether or not the search will be recursive. true/false
        :type recursive: bool
        :param search_term: Enter a search term to perform a search request
        :type search_term: str
        :param sort_order: Sort Order - Ascending,Descending
        :type sort_order: str
        :param parent_id: Specify this to localize the search to a specific item or folder. Omit to use the root
        :type parent_id: str
        :param fields: Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
        :type fields: str
        :param exclude_item_types: Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
        :type exclude_item_types: str
        :param include_item_types: Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
        :type include_item_types: str
        :param any_provider_id_equals: Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
        :type any_provider_id_equals: str
        :param filters: Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
        :type filters: str
        :param is_favorite: Optional filter by items that are marked as favorite, or not.
        :type is_favorite: bool
        :param is_movie: Optional filter for movies.
        :type is_movie: bool
        :param is_series: Optional filter for series.
        :type is_series: bool
        :param is_folder: Optional filter for folders.
        :type is_folder: bool
        :param is_news: Optional filter for news.
        :type is_news: bool
        :param is_kids: Optional filter for kids.
        :type is_kids: bool
        :param is_sports: Optional filter for sports.
        :type is_sports: bool
        :param is_new: Optional filter for IsNew.
        :type is_new: bool
        :param is_premiere: Optional filter for IsPremiere.
        :type is_premiere: bool
        :param is_new_or_premiere: Optional filter for IsNewOrPremiere.
        :type is_new_or_premiere: bool
        :param is_repeat: Optional filter for IsRepeat.
        :type is_repeat: bool
        :param project_to_media: ProjectToMedia
        :type project_to_media: bool
        :param media_types: Optional filter by MediaType. Allows multiple, comma delimited.
        :type media_types: str
        :param image_types: Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
        :type image_types: str
        :param sort_by: Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
        :type sort_by: str
        :param is_played: Optional filter by items that are played, or not.
        :type is_played: bool
        :param genres: Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
        :type genres: str
        :param official_ratings: Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
        :type official_ratings: str
        :param tags: Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
        :type tags: str
        :param exclude_tags: Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
        :type exclude_tags: str
        :param years: Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
        :type years: str
        :param enable_images: Optional, include image information in output
        :type enable_images: bool
        :param enable_user_data: Optional, include user data
        :type enable_user_data: bool
        :param image_type_limit: Optional, the max number of images to return, per image type
        :type image_type_limit: int
        :param enable_image_types: Optional. The image types to include in the output.
        :type enable_image_types: str
        :param person: Optional. If specified, results will be filtered to include only those containing the specified person.
        :type person: str
        :param person_ids: Optional. If specified, results will be filtered to include only those containing the specified person.
        :type person_ids: str
        :param person_types: Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
        :type person_types: str
        :param studios: Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
        :type studios: str
        :param studio_ids: Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
        :type studio_ids: str
        :param artists: Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
        :type artists: str
        :param artist_ids: Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
        :type artist_ids: str
        :param albums: Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
        :type albums: str
        :param ids: Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
        :type ids: str
        :param video_types: Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
        :type video_types: str
        :param containers: Optional filter by Container. Allows multiple, comma delimeted.
        :type containers: str
        :param audio_codecs: Optional filter by AudioCodec. Allows multiple, comma delimeted.
        :type audio_codecs: str
        :param audio_layouts: Optional filter by AudioLayout. Allows multiple, comma delimeted.
        :type audio_layouts: str
        :param video_codecs: Optional filter by VideoCodec. Allows multiple, comma delimeted.
        :type video_codecs: str
        :param extended_video_types: Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
        :type extended_video_types: str
        :param subtitle_codecs: Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
        :type subtitle_codecs: str
        :param path: Optional filter by Path.
        :type path: str
        :param user_id: User Id
        :type user_id: str
        :param min_official_rating: Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
        :type min_official_rating: str
        :param is_locked: Optional filter by items that are locked.
        :type is_locked: bool
        :param is_place_holder: Optional filter by items that are placeholders
        :type is_place_holder: bool
        :param has_official_rating: Optional filter by items that have official ratings
        :type has_official_rating: bool
        :param group_items_into_collections: Whether or not to hide items behind their boxsets.
        :type group_items_into_collections: bool
        :param is3_d: Optional filter by items that are 3D, or not.
        :type is3_d: bool
        :param series_status: Optional filter by Series Status. Allows multiple, comma delimeted.
        :type series_status: str
        :param name_starts_with_or_greater: Optional filter by items whose name is sorted equally or greater than a given input string.
        :type name_starts_with_or_greater: str
        :param artist_starts_with_or_greater: Optional filter by items whose name is sorted equally or greater than a given input string.
        :type artist_starts_with_or_greater: str
        :param album_artist_starts_with_or_greater: Optional filter by items whose name is sorted equally or greater than a given input string.
        :type album_artist_starts_with_or_greater: str
        :param name_starts_with: Optional filter by items whose name is sorted equally than a given input string.
        :type name_starts_with: str
        :param name_less_than: Optional filter by items whose name is equally or lesser than a given input string.
        :type name_less_than: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_trailers_serialize(
            artist_type=artist_type,
            max_official_rating=max_official_rating,
            has_theme_song=has_theme_song,
            has_theme_video=has_theme_video,
            has_subtitles=has_subtitles,
            has_special_feature=has_special_feature,
            has_trailer=has_trailer,
            adjacent_to=adjacent_to,
            min_index_number=min_index_number,
            min_start_date=min_start_date,
            max_start_date=max_start_date,
            min_end_date=min_end_date,
            max_end_date=max_end_date,
            min_players=min_players,
            max_players=max_players,
            parent_index_number=parent_index_number,
            has_parental_rating=has_parental_rating,
            is_hd=is_hd,
            is_unaired=is_unaired,
            min_community_rating=min_community_rating,
            min_critic_rating=min_critic_rating,
            aired_during_season=aired_during_season,
            min_premiere_date=min_premiere_date,
            min_date_last_saved=min_date_last_saved,
            min_date_last_saved_for_user=min_date_last_saved_for_user,
            max_premiere_date=max_premiere_date,
            has_overview=has_overview,
            has_imdb_id=has_imdb_id,
            has_tmdb_id=has_tmdb_id,
            has_tvdb_id=has_tvdb_id,
            exclude_item_ids=exclude_item_ids,
            start_index=start_index,
            limit=limit,
            recursive=recursive,
            search_term=search_term,
            sort_order=sort_order,
            parent_id=parent_id,
            fields=fields,
            exclude_item_types=exclude_item_types,
            include_item_types=include_item_types,
            any_provider_id_equals=any_provider_id_equals,
            filters=filters,
            is_favorite=is_favorite,
            is_movie=is_movie,
            is_series=is_series,
            is_folder=is_folder,
            is_news=is_news,
            is_kids=is_kids,
            is_sports=is_sports,
            is_new=is_new,
            is_premiere=is_premiere,
            is_new_or_premiere=is_new_or_premiere,
            is_repeat=is_repeat,
            project_to_media=project_to_media,
            media_types=media_types,
            image_types=image_types,
            sort_by=sort_by,
            is_played=is_played,
            genres=genres,
            official_ratings=official_ratings,
            tags=tags,
            exclude_tags=exclude_tags,
            years=years,
            enable_images=enable_images,
            enable_user_data=enable_user_data,
            image_type_limit=image_type_limit,
            enable_image_types=enable_image_types,
            person=person,
            person_ids=person_ids,
            person_types=person_types,
            studios=studios,
            studio_ids=studio_ids,
            artists=artists,
            artist_ids=artist_ids,
            albums=albums,
            ids=ids,
            video_types=video_types,
            containers=containers,
            audio_codecs=audio_codecs,
            audio_layouts=audio_layouts,
            video_codecs=video_codecs,
            extended_video_types=extended_video_types,
            subtitle_codecs=subtitle_codecs,
            path=path,
            user_id=user_id,
            min_official_rating=min_official_rating,
            is_locked=is_locked,
            is_place_holder=is_place_holder,
            has_official_rating=has_official_rating,
            group_items_into_collections=group_items_into_collections,
            is3_d=is3_d,
            series_status=series_status,
            name_starts_with_or_greater=name_starts_with_or_greater,
            artist_starts_with_or_greater=artist_starts_with_or_greater,
            album_artist_starts_with_or_greater=album_artist_starts_with_or_greater,
            name_starts_with=name_starts_with,
            name_less_than=name_less_than,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "QueryResultBaseItemDto",
            '400': None,
            '401': None,
            '403': None,
            '404': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_trailers_without_preload_content(
        self,
        artist_type: Annotated[Optional[StrictStr], Field(description="Artist or AlbumArtist")] = None,
        max_official_rating: Annotated[Optional[StrictStr], Field(description="Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).")] = None,
        has_theme_song: Annotated[Optional[StrictBool], Field(description="Optional filter by items with theme songs.")] = None,
        has_theme_video: Annotated[Optional[StrictBool], Field(description="Optional filter by items with theme videos.")] = None,
        has_subtitles: Annotated[Optional[StrictBool], Field(description="Optional filter by items with subtitles.")] = None,
        has_special_feature: Annotated[Optional[StrictBool], Field(description="Optional filter by items with special features.")] = None,
        has_trailer: Annotated[Optional[StrictBool], Field(description="Optional filter by items with trailers.")] = None,
        adjacent_to: Annotated[Optional[StrictStr], Field(description="Optional. Return items that are siblings of a supplied item.")] = None,
        min_index_number: Annotated[Optional[StrictInt], Field(description="Optional filter by minimum index number.")] = None,
        min_start_date: Annotated[Optional[StrictStr], Field(description="Optional. The minimum premiere date. Format = ISO")] = None,
        max_start_date: Annotated[Optional[StrictStr], Field(description="Optional. The maximum premiere date. Format = ISO")] = None,
        min_end_date: Annotated[Optional[StrictStr], Field(description="Optional. The minimum premiere date. Format = ISO")] = None,
        max_end_date: Annotated[Optional[StrictStr], Field(description="Optional. The maximum premiere date. Format = ISO")] = None,
        min_players: Annotated[Optional[StrictInt], Field(description="Optional filter by minimum number of game players.")] = None,
        max_players: Annotated[Optional[StrictInt], Field(description="Optional filter by maximum number of game players.")] = None,
        parent_index_number: Annotated[Optional[StrictInt], Field(description="Optional filter by parent index number.")] = None,
        has_parental_rating: Annotated[Optional[StrictBool], Field(description="Optional filter by items that have or do not have a parental rating")] = None,
        is_hd: Annotated[Optional[StrictBool], Field(description="Optional filter by items that are HD or not.")] = None,
        is_unaired: Annotated[Optional[StrictBool], Field(description="Optional filter by items that are unaired episodes or not.")] = None,
        min_community_rating: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Optional filter by minimum community rating.")] = None,
        min_critic_rating: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Optional filter by minimum critic rating.")] = None,
        aired_during_season: Annotated[Optional[StrictInt], Field(description="Gets all episodes that aired during a season, including specials.")] = None,
        min_premiere_date: Annotated[Optional[StrictStr], Field(description="Optional. The minimum premiere date. Format = ISO")] = None,
        min_date_last_saved: Annotated[Optional[StrictStr], Field(description="Optional. The minimum premiere date. Format = ISO")] = None,
        min_date_last_saved_for_user: Annotated[Optional[StrictStr], Field(description="Optional. The minimum premiere date. Format = ISO")] = None,
        max_premiere_date: Annotated[Optional[StrictStr], Field(description="Optional. The maximum premiere date. Format = ISO")] = None,
        has_overview: Annotated[Optional[StrictBool], Field(description="Optional filter by items that have an overview or not.")] = None,
        has_imdb_id: Annotated[Optional[StrictBool], Field(description="Optional filter by items that have an imdb id or not.")] = None,
        has_tmdb_id: Annotated[Optional[StrictBool], Field(description="Optional filter by items that have a tmdb id or not.")] = None,
        has_tvdb_id: Annotated[Optional[StrictBool], Field(description="Optional filter by items that have a tvdb id or not.")] = None,
        exclude_item_ids: Annotated[Optional[StrictStr], Field(description="Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.")] = None,
        start_index: Annotated[Optional[StrictInt], Field(description="Optional. The record index to start at. All items with a lower index will be dropped from the results.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Optional. The maximum number of records to return")] = None,
        recursive: Annotated[Optional[StrictBool], Field(description="When searching within folders, this determines whether or not the search will be recursive. true/false")] = None,
        search_term: Annotated[Optional[StrictStr], Field(description="Enter a search term to perform a search request")] = None,
        sort_order: Annotated[Optional[StrictStr], Field(description="Sort Order - Ascending,Descending")] = None,
        parent_id: Annotated[Optional[StrictStr], Field(description="Specify this to localize the search to a specific item or folder. Omit to use the root")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines")] = None,
        exclude_item_types: Annotated[Optional[StrictStr], Field(description="Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.")] = None,
        include_item_types: Annotated[Optional[StrictStr], Field(description="Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.")] = None,
        any_provider_id_equals: Annotated[Optional[StrictStr], Field(description="Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.")] = None,
        filters: Annotated[Optional[StrictStr], Field(description="Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes")] = None,
        is_favorite: Annotated[Optional[StrictBool], Field(description="Optional filter by items that are marked as favorite, or not.")] = None,
        is_movie: Annotated[Optional[StrictBool], Field(description="Optional filter for movies.")] = None,
        is_series: Annotated[Optional[StrictBool], Field(description="Optional filter for series.")] = None,
        is_folder: Annotated[Optional[StrictBool], Field(description="Optional filter for folders.")] = None,
        is_news: Annotated[Optional[StrictBool], Field(description="Optional filter for news.")] = None,
        is_kids: Annotated[Optional[StrictBool], Field(description="Optional filter for kids.")] = None,
        is_sports: Annotated[Optional[StrictBool], Field(description="Optional filter for sports.")] = None,
        is_new: Annotated[Optional[StrictBool], Field(description="Optional filter for IsNew.")] = None,
        is_premiere: Annotated[Optional[StrictBool], Field(description="Optional filter for IsPremiere.")] = None,
        is_new_or_premiere: Annotated[Optional[StrictBool], Field(description="Optional filter for IsNewOrPremiere.")] = None,
        is_repeat: Annotated[Optional[StrictBool], Field(description="Optional filter for IsRepeat.")] = None,
        project_to_media: Annotated[Optional[StrictBool], Field(description="ProjectToMedia")] = None,
        media_types: Annotated[Optional[StrictStr], Field(description="Optional filter by MediaType. Allows multiple, comma delimited.")] = None,
        image_types: Annotated[Optional[StrictStr], Field(description="Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.")] = None,
        sort_by: Annotated[Optional[StrictStr], Field(description="Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime")] = None,
        is_played: Annotated[Optional[StrictBool], Field(description="Optional filter by items that are played, or not.")] = None,
        genres: Annotated[Optional[StrictStr], Field(description="Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.")] = None,
        official_ratings: Annotated[Optional[StrictStr], Field(description="Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.")] = None,
        tags: Annotated[Optional[StrictStr], Field(description="Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.")] = None,
        exclude_tags: Annotated[Optional[StrictStr], Field(description="Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.")] = None,
        years: Annotated[Optional[StrictStr], Field(description="Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.")] = None,
        enable_images: Annotated[Optional[StrictBool], Field(description="Optional, include image information in output")] = None,
        enable_user_data: Annotated[Optional[StrictBool], Field(description="Optional, include user data")] = None,
        image_type_limit: Annotated[Optional[StrictInt], Field(description="Optional, the max number of images to return, per image type")] = None,
        enable_image_types: Annotated[Optional[StrictStr], Field(description="Optional. The image types to include in the output.")] = None,
        person: Annotated[Optional[StrictStr], Field(description="Optional. If specified, results will be filtered to include only those containing the specified person.")] = None,
        person_ids: Annotated[Optional[StrictStr], Field(description="Optional. If specified, results will be filtered to include only those containing the specified person.")] = None,
        person_types: Annotated[Optional[StrictStr], Field(description="Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited")] = None,
        studios: Annotated[Optional[StrictStr], Field(description="Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.")] = None,
        studio_ids: Annotated[Optional[StrictStr], Field(description="Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.")] = None,
        artists: Annotated[Optional[StrictStr], Field(description="Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.")] = None,
        artist_ids: Annotated[Optional[StrictStr], Field(description="Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.")] = None,
        albums: Annotated[Optional[StrictStr], Field(description="Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.")] = None,
        ids: Annotated[Optional[StrictStr], Field(description="Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.")] = None,
        video_types: Annotated[Optional[StrictStr], Field(description="Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.")] = None,
        containers: Annotated[Optional[StrictStr], Field(description="Optional filter by Container. Allows multiple, comma delimeted.")] = None,
        audio_codecs: Annotated[Optional[StrictStr], Field(description="Optional filter by AudioCodec. Allows multiple, comma delimeted.")] = None,
        audio_layouts: Annotated[Optional[StrictStr], Field(description="Optional filter by AudioLayout. Allows multiple, comma delimeted.")] = None,
        video_codecs: Annotated[Optional[StrictStr], Field(description="Optional filter by VideoCodec. Allows multiple, comma delimeted.")] = None,
        extended_video_types: Annotated[Optional[StrictStr], Field(description="Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.")] = None,
        subtitle_codecs: Annotated[Optional[StrictStr], Field(description="Optional filter by SubtitleCodec. Allows multiple, comma delimeted.")] = None,
        path: Annotated[Optional[StrictStr], Field(description="Optional filter by Path.")] = None,
        user_id: Annotated[Optional[StrictStr], Field(description="User Id")] = None,
        min_official_rating: Annotated[Optional[StrictStr], Field(description="Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).")] = None,
        is_locked: Annotated[Optional[StrictBool], Field(description="Optional filter by items that are locked.")] = None,
        is_place_holder: Annotated[Optional[StrictBool], Field(description="Optional filter by items that are placeholders")] = None,
        has_official_rating: Annotated[Optional[StrictBool], Field(description="Optional filter by items that have official ratings")] = None,
        group_items_into_collections: Annotated[Optional[StrictBool], Field(description="Whether or not to hide items behind their boxsets.")] = None,
        is3_d: Annotated[Optional[StrictBool], Field(description="Optional filter by items that are 3D, or not.")] = None,
        series_status: Annotated[Optional[StrictStr], Field(description="Optional filter by Series Status. Allows multiple, comma delimeted.")] = None,
        name_starts_with_or_greater: Annotated[Optional[StrictStr], Field(description="Optional filter by items whose name is sorted equally or greater than a given input string.")] = None,
        artist_starts_with_or_greater: Annotated[Optional[StrictStr], Field(description="Optional filter by items whose name is sorted equally or greater than a given input string.")] = None,
        album_artist_starts_with_or_greater: Annotated[Optional[StrictStr], Field(description="Optional filter by items whose name is sorted equally or greater than a given input string.")] = None,
        name_starts_with: Annotated[Optional[StrictStr], Field(description="Optional filter by items whose name is sorted equally than a given input string.")] = None,
        name_less_than: Annotated[Optional[StrictStr], Field(description="Optional filter by items whose name is equally or lesser than a given input string.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Finds movies and trailers similar to a given trailer.

        Requires authentication as user

        :param artist_type: Artist or AlbumArtist
        :type artist_type: str
        :param max_official_rating: Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
        :type max_official_rating: str
        :param has_theme_song: Optional filter by items with theme songs.
        :type has_theme_song: bool
        :param has_theme_video: Optional filter by items with theme videos.
        :type has_theme_video: bool
        :param has_subtitles: Optional filter by items with subtitles.
        :type has_subtitles: bool
        :param has_special_feature: Optional filter by items with special features.
        :type has_special_feature: bool
        :param has_trailer: Optional filter by items with trailers.
        :type has_trailer: bool
        :param adjacent_to: Optional. Return items that are siblings of a supplied item.
        :type adjacent_to: str
        :param min_index_number: Optional filter by minimum index number.
        :type min_index_number: int
        :param min_start_date: Optional. The minimum premiere date. Format = ISO
        :type min_start_date: str
        :param max_start_date: Optional. The maximum premiere date. Format = ISO
        :type max_start_date: str
        :param min_end_date: Optional. The minimum premiere date. Format = ISO
        :type min_end_date: str
        :param max_end_date: Optional. The maximum premiere date. Format = ISO
        :type max_end_date: str
        :param min_players: Optional filter by minimum number of game players.
        :type min_players: int
        :param max_players: Optional filter by maximum number of game players.
        :type max_players: int
        :param parent_index_number: Optional filter by parent index number.
        :type parent_index_number: int
        :param has_parental_rating: Optional filter by items that have or do not have a parental rating
        :type has_parental_rating: bool
        :param is_hd: Optional filter by items that are HD or not.
        :type is_hd: bool
        :param is_unaired: Optional filter by items that are unaired episodes or not.
        :type is_unaired: bool
        :param min_community_rating: Optional filter by minimum community rating.
        :type min_community_rating: float
        :param min_critic_rating: Optional filter by minimum critic rating.
        :type min_critic_rating: float
        :param aired_during_season: Gets all episodes that aired during a season, including specials.
        :type aired_during_season: int
        :param min_premiere_date: Optional. The minimum premiere date. Format = ISO
        :type min_premiere_date: str
        :param min_date_last_saved: Optional. The minimum premiere date. Format = ISO
        :type min_date_last_saved: str
        :param min_date_last_saved_for_user: Optional. The minimum premiere date. Format = ISO
        :type min_date_last_saved_for_user: str
        :param max_premiere_date: Optional. The maximum premiere date. Format = ISO
        :type max_premiere_date: str
        :param has_overview: Optional filter by items that have an overview or not.
        :type has_overview: bool
        :param has_imdb_id: Optional filter by items that have an imdb id or not.
        :type has_imdb_id: bool
        :param has_tmdb_id: Optional filter by items that have a tmdb id or not.
        :type has_tmdb_id: bool
        :param has_tvdb_id: Optional filter by items that have a tvdb id or not.
        :type has_tvdb_id: bool
        :param exclude_item_ids: Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
        :type exclude_item_ids: str
        :param start_index: Optional. The record index to start at. All items with a lower index will be dropped from the results.
        :type start_index: int
        :param limit: Optional. The maximum number of records to return
        :type limit: int
        :param recursive: When searching within folders, this determines whether or not the search will be recursive. true/false
        :type recursive: bool
        :param search_term: Enter a search term to perform a search request
        :type search_term: str
        :param sort_order: Sort Order - Ascending,Descending
        :type sort_order: str
        :param parent_id: Specify this to localize the search to a specific item or folder. Omit to use the root
        :type parent_id: str
        :param fields: Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
        :type fields: str
        :param exclude_item_types: Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
        :type exclude_item_types: str
        :param include_item_types: Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
        :type include_item_types: str
        :param any_provider_id_equals: Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
        :type any_provider_id_equals: str
        :param filters: Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
        :type filters: str
        :param is_favorite: Optional filter by items that are marked as favorite, or not.
        :type is_favorite: bool
        :param is_movie: Optional filter for movies.
        :type is_movie: bool
        :param is_series: Optional filter for series.
        :type is_series: bool
        :param is_folder: Optional filter for folders.
        :type is_folder: bool
        :param is_news: Optional filter for news.
        :type is_news: bool
        :param is_kids: Optional filter for kids.
        :type is_kids: bool
        :param is_sports: Optional filter for sports.
        :type is_sports: bool
        :param is_new: Optional filter for IsNew.
        :type is_new: bool
        :param is_premiere: Optional filter for IsPremiere.
        :type is_premiere: bool
        :param is_new_or_premiere: Optional filter for IsNewOrPremiere.
        :type is_new_or_premiere: bool
        :param is_repeat: Optional filter for IsRepeat.
        :type is_repeat: bool
        :param project_to_media: ProjectToMedia
        :type project_to_media: bool
        :param media_types: Optional filter by MediaType. Allows multiple, comma delimited.
        :type media_types: str
        :param image_types: Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
        :type image_types: str
        :param sort_by: Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
        :type sort_by: str
        :param is_played: Optional filter by items that are played, or not.
        :type is_played: bool
        :param genres: Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
        :type genres: str
        :param official_ratings: Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
        :type official_ratings: str
        :param tags: Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
        :type tags: str
        :param exclude_tags: Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
        :type exclude_tags: str
        :param years: Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
        :type years: str
        :param enable_images: Optional, include image information in output
        :type enable_images: bool
        :param enable_user_data: Optional, include user data
        :type enable_user_data: bool
        :param image_type_limit: Optional, the max number of images to return, per image type
        :type image_type_limit: int
        :param enable_image_types: Optional. The image types to include in the output.
        :type enable_image_types: str
        :param person: Optional. If specified, results will be filtered to include only those containing the specified person.
        :type person: str
        :param person_ids: Optional. If specified, results will be filtered to include only those containing the specified person.
        :type person_ids: str
        :param person_types: Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
        :type person_types: str
        :param studios: Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
        :type studios: str
        :param studio_ids: Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
        :type studio_ids: str
        :param artists: Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
        :type artists: str
        :param artist_ids: Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
        :type artist_ids: str
        :param albums: Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
        :type albums: str
        :param ids: Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
        :type ids: str
        :param video_types: Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
        :type video_types: str
        :param containers: Optional filter by Container. Allows multiple, comma delimeted.
        :type containers: str
        :param audio_codecs: Optional filter by AudioCodec. Allows multiple, comma delimeted.
        :type audio_codecs: str
        :param audio_layouts: Optional filter by AudioLayout. Allows multiple, comma delimeted.
        :type audio_layouts: str
        :param video_codecs: Optional filter by VideoCodec. Allows multiple, comma delimeted.
        :type video_codecs: str
        :param extended_video_types: Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
        :type extended_video_types: str
        :param subtitle_codecs: Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
        :type subtitle_codecs: str
        :param path: Optional filter by Path.
        :type path: str
        :param user_id: User Id
        :type user_id: str
        :param min_official_rating: Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
        :type min_official_rating: str
        :param is_locked: Optional filter by items that are locked.
        :type is_locked: bool
        :param is_place_holder: Optional filter by items that are placeholders
        :type is_place_holder: bool
        :param has_official_rating: Optional filter by items that have official ratings
        :type has_official_rating: bool
        :param group_items_into_collections: Whether or not to hide items behind their boxsets.
        :type group_items_into_collections: bool
        :param is3_d: Optional filter by items that are 3D, or not.
        :type is3_d: bool
        :param series_status: Optional filter by Series Status. Allows multiple, comma delimeted.
        :type series_status: str
        :param name_starts_with_or_greater: Optional filter by items whose name is sorted equally or greater than a given input string.
        :type name_starts_with_or_greater: str
        :param artist_starts_with_or_greater: Optional filter by items whose name is sorted equally or greater than a given input string.
        :type artist_starts_with_or_greater: str
        :param album_artist_starts_with_or_greater: Optional filter by items whose name is sorted equally or greater than a given input string.
        :type album_artist_starts_with_or_greater: str
        :param name_starts_with: Optional filter by items whose name is sorted equally than a given input string.
        :type name_starts_with: str
        :param name_less_than: Optional filter by items whose name is equally or lesser than a given input string.
        :type name_less_than: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_trailers_serialize(
            artist_type=artist_type,
            max_official_rating=max_official_rating,
            has_theme_song=has_theme_song,
            has_theme_video=has_theme_video,
            has_subtitles=has_subtitles,
            has_special_feature=has_special_feature,
            has_trailer=has_trailer,
            adjacent_to=adjacent_to,
            min_index_number=min_index_number,
            min_start_date=min_start_date,
            max_start_date=max_start_date,
            min_end_date=min_end_date,
            max_end_date=max_end_date,
            min_players=min_players,
            max_players=max_players,
            parent_index_number=parent_index_number,
            has_parental_rating=has_parental_rating,
            is_hd=is_hd,
            is_unaired=is_unaired,
            min_community_rating=min_community_rating,
            min_critic_rating=min_critic_rating,
            aired_during_season=aired_during_season,
            min_premiere_date=min_premiere_date,
            min_date_last_saved=min_date_last_saved,
            min_date_last_saved_for_user=min_date_last_saved_for_user,
            max_premiere_date=max_premiere_date,
            has_overview=has_overview,
            has_imdb_id=has_imdb_id,
            has_tmdb_id=has_tmdb_id,
            has_tvdb_id=has_tvdb_id,
            exclude_item_ids=exclude_item_ids,
            start_index=start_index,
            limit=limit,
            recursive=recursive,
            search_term=search_term,
            sort_order=sort_order,
            parent_id=parent_id,
            fields=fields,
            exclude_item_types=exclude_item_types,
            include_item_types=include_item_types,
            any_provider_id_equals=any_provider_id_equals,
            filters=filters,
            is_favorite=is_favorite,
            is_movie=is_movie,
            is_series=is_series,
            is_folder=is_folder,
            is_news=is_news,
            is_kids=is_kids,
            is_sports=is_sports,
            is_new=is_new,
            is_premiere=is_premiere,
            is_new_or_premiere=is_new_or_premiere,
            is_repeat=is_repeat,
            project_to_media=project_to_media,
            media_types=media_types,
            image_types=image_types,
            sort_by=sort_by,
            is_played=is_played,
            genres=genres,
            official_ratings=official_ratings,
            tags=tags,
            exclude_tags=exclude_tags,
            years=years,
            enable_images=enable_images,
            enable_user_data=enable_user_data,
            image_type_limit=image_type_limit,
            enable_image_types=enable_image_types,
            person=person,
            person_ids=person_ids,
            person_types=person_types,
            studios=studios,
            studio_ids=studio_ids,
            artists=artists,
            artist_ids=artist_ids,
            albums=albums,
            ids=ids,
            video_types=video_types,
            containers=containers,
            audio_codecs=audio_codecs,
            audio_layouts=audio_layouts,
            video_codecs=video_codecs,
            extended_video_types=extended_video_types,
            subtitle_codecs=subtitle_codecs,
            path=path,
            user_id=user_id,
            min_official_rating=min_official_rating,
            is_locked=is_locked,
            is_place_holder=is_place_holder,
            has_official_rating=has_official_rating,
            group_items_into_collections=group_items_into_collections,
            is3_d=is3_d,
            series_status=series_status,
            name_starts_with_or_greater=name_starts_with_or_greater,
            artist_starts_with_or_greater=artist_starts_with_or_greater,
            album_artist_starts_with_or_greater=album_artist_starts_with_or_greater,
            name_starts_with=name_starts_with,
            name_less_than=name_less_than,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "QueryResultBaseItemDto",
            '400': None,
            '401': None,
            '403': None,
            '404': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_trailers_serialize(
        self,
        artist_type,
        max_official_rating,
        has_theme_song,
        has_theme_video,
        has_subtitles,
        has_special_feature,
        has_trailer,
        adjacent_to,
        min_index_number,
        min_start_date,
        max_start_date,
        min_end_date,
        max_end_date,
        min_players,
        max_players,
        parent_index_number,
        has_parental_rating,
        is_hd,
        is_unaired,
        min_community_rating,
        min_critic_rating,
        aired_during_season,
        min_premiere_date,
        min_date_last_saved,
        min_date_last_saved_for_user,
        max_premiere_date,
        has_overview,
        has_imdb_id,
        has_tmdb_id,
        has_tvdb_id,
        exclude_item_ids,
        start_index,
        limit,
        recursive,
        search_term,
        sort_order,
        parent_id,
        fields,
        exclude_item_types,
        include_item_types,
        any_provider_id_equals,
        filters,
        is_favorite,
        is_movie,
        is_series,
        is_folder,
        is_news,
        is_kids,
        is_sports,
        is_new,
        is_premiere,
        is_new_or_premiere,
        is_repeat,
        project_to_media,
        media_types,
        image_types,
        sort_by,
        is_played,
        genres,
        official_ratings,
        tags,
        exclude_tags,
        years,
        enable_images,
        enable_user_data,
        image_type_limit,
        enable_image_types,
        person,
        person_ids,
        person_types,
        studios,
        studio_ids,
        artists,
        artist_ids,
        albums,
        ids,
        video_types,
        containers,
        audio_codecs,
        audio_layouts,
        video_codecs,
        extended_video_types,
        subtitle_codecs,
        path,
        user_id,
        min_official_rating,
        is_locked,
        is_place_holder,
        has_official_rating,
        group_items_into_collections,
        is3_d,
        series_status,
        name_starts_with_or_greater,
        artist_starts_with_or_greater,
        album_artist_starts_with_or_greater,
        name_starts_with,
        name_less_than,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if artist_type is not None:
            
            _query_params.append(('ArtistType', artist_type))
            
        if max_official_rating is not None:
            
            _query_params.append(('MaxOfficialRating', max_official_rating))
            
        if has_theme_song is not None:
            
            _query_params.append(('HasThemeSong', has_theme_song))
            
        if has_theme_video is not None:
            
            _query_params.append(('HasThemeVideo', has_theme_video))
            
        if has_subtitles is not None:
            
            _query_params.append(('HasSubtitles', has_subtitles))
            
        if has_special_feature is not None:
            
            _query_params.append(('HasSpecialFeature', has_special_feature))
            
        if has_trailer is not None:
            
            _query_params.append(('HasTrailer', has_trailer))
            
        if adjacent_to is not None:
            
            _query_params.append(('AdjacentTo', adjacent_to))
            
        if min_index_number is not None:
            
            _query_params.append(('MinIndexNumber', min_index_number))
            
        if min_start_date is not None:
            
            _query_params.append(('MinStartDate', min_start_date))
            
        if max_start_date is not None:
            
            _query_params.append(('MaxStartDate', max_start_date))
            
        if min_end_date is not None:
            
            _query_params.append(('MinEndDate', min_end_date))
            
        if max_end_date is not None:
            
            _query_params.append(('MaxEndDate', max_end_date))
            
        if min_players is not None:
            
            _query_params.append(('MinPlayers', min_players))
            
        if max_players is not None:
            
            _query_params.append(('MaxPlayers', max_players))
            
        if parent_index_number is not None:
            
            _query_params.append(('ParentIndexNumber', parent_index_number))
            
        if has_parental_rating is not None:
            
            _query_params.append(('HasParentalRating', has_parental_rating))
            
        if is_hd is not None:
            
            _query_params.append(('IsHD', is_hd))
            
        if is_unaired is not None:
            
            _query_params.append(('IsUnaired', is_unaired))
            
        if min_community_rating is not None:
            
            _query_params.append(('MinCommunityRating', min_community_rating))
            
        if min_critic_rating is not None:
            
            _query_params.append(('MinCriticRating', min_critic_rating))
            
        if aired_during_season is not None:
            
            _query_params.append(('AiredDuringSeason', aired_during_season))
            
        if min_premiere_date is not None:
            
            _query_params.append(('MinPremiereDate', min_premiere_date))
            
        if min_date_last_saved is not None:
            
            _query_params.append(('MinDateLastSaved', min_date_last_saved))
            
        if min_date_last_saved_for_user is not None:
            
            _query_params.append(('MinDateLastSavedForUser', min_date_last_saved_for_user))
            
        if max_premiere_date is not None:
            
            _query_params.append(('MaxPremiereDate', max_premiere_date))
            
        if has_overview is not None:
            
            _query_params.append(('HasOverview', has_overview))
            
        if has_imdb_id is not None:
            
            _query_params.append(('HasImdbId', has_imdb_id))
            
        if has_tmdb_id is not None:
            
            _query_params.append(('HasTmdbId', has_tmdb_id))
            
        if has_tvdb_id is not None:
            
            _query_params.append(('HasTvdbId', has_tvdb_id))
            
        if exclude_item_ids is not None:
            
            _query_params.append(('ExcludeItemIds', exclude_item_ids))
            
        if start_index is not None:
            
            _query_params.append(('StartIndex', start_index))
            
        if limit is not None:
            
            _query_params.append(('Limit', limit))
            
        if recursive is not None:
            
            _query_params.append(('Recursive', recursive))
            
        if search_term is not None:
            
            _query_params.append(('SearchTerm', search_term))
            
        if sort_order is not None:
            
            _query_params.append(('SortOrder', sort_order))
            
        if parent_id is not None:
            
            _query_params.append(('ParentId', parent_id))
            
        if fields is not None:
            
            _query_params.append(('Fields', fields))
            
        if exclude_item_types is not None:
            
            _query_params.append(('ExcludeItemTypes', exclude_item_types))
            
        if include_item_types is not None:
            
            _query_params.append(('IncludeItemTypes', include_item_types))
            
        if any_provider_id_equals is not None:
            
            _query_params.append(('AnyProviderIdEquals', any_provider_id_equals))
            
        if filters is not None:
            
            _query_params.append(('Filters', filters))
            
        if is_favorite is not None:
            
            _query_params.append(('IsFavorite', is_favorite))
            
        if is_movie is not None:
            
            _query_params.append(('IsMovie', is_movie))
            
        if is_series is not None:
            
            _query_params.append(('IsSeries', is_series))
            
        if is_folder is not None:
            
            _query_params.append(('IsFolder', is_folder))
            
        if is_news is not None:
            
            _query_params.append(('IsNews', is_news))
            
        if is_kids is not None:
            
            _query_params.append(('IsKids', is_kids))
            
        if is_sports is not None:
            
            _query_params.append(('IsSports', is_sports))
            
        if is_new is not None:
            
            _query_params.append(('IsNew', is_new))
            
        if is_premiere is not None:
            
            _query_params.append(('IsPremiere', is_premiere))
            
        if is_new_or_premiere is not None:
            
            _query_params.append(('IsNewOrPremiere', is_new_or_premiere))
            
        if is_repeat is not None:
            
            _query_params.append(('IsRepeat', is_repeat))
            
        if project_to_media is not None:
            
            _query_params.append(('ProjectToMedia', project_to_media))
            
        if media_types is not None:
            
            _query_params.append(('MediaTypes', media_types))
            
        if image_types is not None:
            
            _query_params.append(('ImageTypes', image_types))
            
        if sort_by is not None:
            
            _query_params.append(('SortBy', sort_by))
            
        if is_played is not None:
            
            _query_params.append(('IsPlayed', is_played))
            
        if genres is not None:
            
            _query_params.append(('Genres', genres))
            
        if official_ratings is not None:
            
            _query_params.append(('OfficialRatings', official_ratings))
            
        if tags is not None:
            
            _query_params.append(('Tags', tags))
            
        if exclude_tags is not None:
            
            _query_params.append(('ExcludeTags', exclude_tags))
            
        if years is not None:
            
            _query_params.append(('Years', years))
            
        if enable_images is not None:
            
            _query_params.append(('EnableImages', enable_images))
            
        if enable_user_data is not None:
            
            _query_params.append(('EnableUserData', enable_user_data))
            
        if image_type_limit is not None:
            
            _query_params.append(('ImageTypeLimit', image_type_limit))
            
        if enable_image_types is not None:
            
            _query_params.append(('EnableImageTypes', enable_image_types))
            
        if person is not None:
            
            _query_params.append(('Person', person))
            
        if person_ids is not None:
            
            _query_params.append(('PersonIds', person_ids))
            
        if person_types is not None:
            
            _query_params.append(('PersonTypes', person_types))
            
        if studios is not None:
            
            _query_params.append(('Studios', studios))
            
        if studio_ids is not None:
            
            _query_params.append(('StudioIds', studio_ids))
            
        if artists is not None:
            
            _query_params.append(('Artists', artists))
            
        if artist_ids is not None:
            
            _query_params.append(('ArtistIds', artist_ids))
            
        if albums is not None:
            
            _query_params.append(('Albums', albums))
            
        if ids is not None:
            
            _query_params.append(('Ids', ids))
            
        if video_types is not None:
            
            _query_params.append(('VideoTypes', video_types))
            
        if containers is not None:
            
            _query_params.append(('Containers', containers))
            
        if audio_codecs is not None:
            
            _query_params.append(('AudioCodecs', audio_codecs))
            
        if audio_layouts is not None:
            
            _query_params.append(('AudioLayouts', audio_layouts))
            
        if video_codecs is not None:
            
            _query_params.append(('VideoCodecs', video_codecs))
            
        if extended_video_types is not None:
            
            _query_params.append(('ExtendedVideoTypes', extended_video_types))
            
        if subtitle_codecs is not None:
            
            _query_params.append(('SubtitleCodecs', subtitle_codecs))
            
        if path is not None:
            
            _query_params.append(('Path', path))
            
        if user_id is not None:
            
            _query_params.append(('UserId', user_id))
            
        if min_official_rating is not None:
            
            _query_params.append(('MinOfficialRating', min_official_rating))
            
        if is_locked is not None:
            
            _query_params.append(('IsLocked', is_locked))
            
        if is_place_holder is not None:
            
            _query_params.append(('IsPlaceHolder', is_place_holder))
            
        if has_official_rating is not None:
            
            _query_params.append(('HasOfficialRating', has_official_rating))
            
        if group_items_into_collections is not None:
            
            _query_params.append(('GroupItemsIntoCollections', group_items_into_collections))
            
        if is3_d is not None:
            
            _query_params.append(('Is3D', is3_d))
            
        if series_status is not None:
            
            _query_params.append(('SeriesStatus', series_status))
            
        if name_starts_with_or_greater is not None:
            
            _query_params.append(('NameStartsWithOrGreater', name_starts_with_or_greater))
            
        if artist_starts_with_or_greater is not None:
            
            _query_params.append(('ArtistStartsWithOrGreater', artist_starts_with_or_greater))
            
        if album_artist_starts_with_or_greater is not None:
            
            _query_params.append(('AlbumArtistStartsWithOrGreater', album_artist_starts_with_or_greater))
            
        if name_starts_with is not None:
            
            _query_params.append(('NameStartsWith', name_starts_with))
            
        if name_less_than is not None:
            
            _query_params.append(('NameLessThan', name_less_than))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json', 
                'application/xml'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
            'apikeyauth', 
            'embyauth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/Trailers',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


