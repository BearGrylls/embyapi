# coding: utf-8

"""
    Emby Server REST API

    Explore the Emby Server API

    The version of the OpenAPI document: 4.8.7.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictInt, StrictStr
from typing import Optional
from typing_extensions import Annotated
from embyapi.models.subtitle_delivery_method import SubtitleDeliveryMethod

from embyapi.api_client import ApiClient, RequestSerialized
from embyapi.api_response import ApiResponse
from embyapi.rest import RESTResponseType


class AudioServiceApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def get_audio_by_id_by_streamfilename(
        self,
        stream_file_name: StrictStr,
        id: Annotated[StrictStr, Field(description="Item Id")],
        container: Annotated[StrictStr, Field(description="Container")],
        device_profile_id: Annotated[Optional[StrictStr], Field(description="Optional. The dlna device profile id to utilize.")] = None,
        device_id: Annotated[Optional[StrictStr], Field(description="The device id of the client requesting. Used to stop encoding processes when needed.")] = None,
        audio_codec: Annotated[Optional[StrictStr], Field(description="Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.")] = None,
        enable_auto_stream_copy: Annotated[Optional[StrictBool], Field(description="Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.")] = None,
        audio_sample_rate: Annotated[Optional[StrictInt], Field(description="Optional. Specify a specific audio sample rate, e.g. 44100")] = None,
        audio_bit_rate: Annotated[Optional[StrictInt], Field(description="Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.")] = None,
        audio_channels: Annotated[Optional[StrictInt], Field(description="Optional. Specify a specific number of audio channels to encode to, e.g. 2")] = None,
        max_audio_channels: Annotated[Optional[StrictInt], Field(description="Optional. Specify a maximum number of audio channels to encode to, e.g. 2")] = None,
        static: Annotated[Optional[StrictBool], Field(description="Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false")] = None,
        copy_timestamps: Annotated[Optional[StrictBool], Field(description="Whether or not to copy timestamps when transcoding with an offset. Defaults to false.")] = None,
        start_time_ticks: Annotated[Optional[StrictInt], Field(description="Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.")] = None,
        width: Annotated[Optional[StrictInt], Field(description="Optional. The fixed horizontal resolution of the encoded video.")] = None,
        height: Annotated[Optional[StrictInt], Field(description="Optional. The fixed vertical resolution of the encoded video.")] = None,
        max_width: Annotated[Optional[StrictInt], Field(description="Optional. The maximum horizontal resolution of the encoded video.")] = None,
        max_height: Annotated[Optional[StrictInt], Field(description="Optional. The maximum vertical resolution of the encoded video.")] = None,
        video_bit_rate: Annotated[Optional[StrictInt], Field(description="Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.")] = None,
        subtitle_stream_index: Annotated[Optional[StrictInt], Field(description="Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.")] = None,
        subtitle_method: Annotated[Optional[SubtitleDeliveryMethod], Field(description="Optional. Specify the subtitle delivery method.")] = None,
        max_video_bit_depth: Annotated[Optional[StrictInt], Field(description="Optional.")] = None,
        video_codec: Annotated[Optional[StrictStr], Field(description="Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.")] = None,
        audio_stream_index: Annotated[Optional[StrictInt], Field(description="Optional. The index of the audio stream to use. If omitted the first audio stream will be used.")] = None,
        video_stream_index: Annotated[Optional[StrictInt], Field(description="Optional. The index of the video stream to use. If omitted the first video stream will be used.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Gets an audio stream

        Requires authentication as user

        :param stream_file_name: (required)
        :type stream_file_name: str
        :param id: Item Id (required)
        :type id: str
        :param container: Container (required)
        :type container: str
        :param device_profile_id: Optional. The dlna device profile id to utilize.
        :type device_profile_id: str
        :param device_id: The device id of the client requesting. Used to stop encoding processes when needed.
        :type device_id: str
        :param audio_codec: Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
        :type audio_codec: str
        :param enable_auto_stream_copy: Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
        :type enable_auto_stream_copy: bool
        :param audio_sample_rate: Optional. Specify a specific audio sample rate, e.g. 44100
        :type audio_sample_rate: int
        :param audio_bit_rate: Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
        :type audio_bit_rate: int
        :param audio_channels: Optional. Specify a specific number of audio channels to encode to, e.g. 2
        :type audio_channels: int
        :param max_audio_channels: Optional. Specify a maximum number of audio channels to encode to, e.g. 2
        :type max_audio_channels: int
        :param static: Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
        :type static: bool
        :param copy_timestamps: Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
        :type copy_timestamps: bool
        :param start_time_ticks: Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
        :type start_time_ticks: int
        :param width: Optional. The fixed horizontal resolution of the encoded video.
        :type width: int
        :param height: Optional. The fixed vertical resolution of the encoded video.
        :type height: int
        :param max_width: Optional. The maximum horizontal resolution of the encoded video.
        :type max_width: int
        :param max_height: Optional. The maximum vertical resolution of the encoded video.
        :type max_height: int
        :param video_bit_rate: Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
        :type video_bit_rate: int
        :param subtitle_stream_index: Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
        :type subtitle_stream_index: int
        :param subtitle_method: Optional. Specify the subtitle delivery method.
        :type subtitle_method: SubtitleDeliveryMethod
        :param max_video_bit_depth: Optional.
        :type max_video_bit_depth: int
        :param video_codec: Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
        :type video_codec: str
        :param audio_stream_index: Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
        :type audio_stream_index: int
        :param video_stream_index: Optional. The index of the video stream to use. If omitted the first video stream will be used.
        :type video_stream_index: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_audio_by_id_by_streamfilename_serialize(
            stream_file_name=stream_file_name,
            id=id,
            container=container,
            device_profile_id=device_profile_id,
            device_id=device_id,
            audio_codec=audio_codec,
            enable_auto_stream_copy=enable_auto_stream_copy,
            audio_sample_rate=audio_sample_rate,
            audio_bit_rate=audio_bit_rate,
            audio_channels=audio_channels,
            max_audio_channels=max_audio_channels,
            static=static,
            copy_timestamps=copy_timestamps,
            start_time_ticks=start_time_ticks,
            width=width,
            height=height,
            max_width=max_width,
            max_height=max_height,
            video_bit_rate=video_bit_rate,
            subtitle_stream_index=subtitle_stream_index,
            subtitle_method=subtitle_method,
            max_video_bit_depth=max_video_bit_depth,
            video_codec=video_codec,
            audio_stream_index=audio_stream_index,
            video_stream_index=video_stream_index,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '400': None,
            '401': None,
            '403': None,
            '404': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_audio_by_id_by_streamfilename_with_http_info(
        self,
        stream_file_name: StrictStr,
        id: Annotated[StrictStr, Field(description="Item Id")],
        container: Annotated[StrictStr, Field(description="Container")],
        device_profile_id: Annotated[Optional[StrictStr], Field(description="Optional. The dlna device profile id to utilize.")] = None,
        device_id: Annotated[Optional[StrictStr], Field(description="The device id of the client requesting. Used to stop encoding processes when needed.")] = None,
        audio_codec: Annotated[Optional[StrictStr], Field(description="Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.")] = None,
        enable_auto_stream_copy: Annotated[Optional[StrictBool], Field(description="Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.")] = None,
        audio_sample_rate: Annotated[Optional[StrictInt], Field(description="Optional. Specify a specific audio sample rate, e.g. 44100")] = None,
        audio_bit_rate: Annotated[Optional[StrictInt], Field(description="Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.")] = None,
        audio_channels: Annotated[Optional[StrictInt], Field(description="Optional. Specify a specific number of audio channels to encode to, e.g. 2")] = None,
        max_audio_channels: Annotated[Optional[StrictInt], Field(description="Optional. Specify a maximum number of audio channels to encode to, e.g. 2")] = None,
        static: Annotated[Optional[StrictBool], Field(description="Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false")] = None,
        copy_timestamps: Annotated[Optional[StrictBool], Field(description="Whether or not to copy timestamps when transcoding with an offset. Defaults to false.")] = None,
        start_time_ticks: Annotated[Optional[StrictInt], Field(description="Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.")] = None,
        width: Annotated[Optional[StrictInt], Field(description="Optional. The fixed horizontal resolution of the encoded video.")] = None,
        height: Annotated[Optional[StrictInt], Field(description="Optional. The fixed vertical resolution of the encoded video.")] = None,
        max_width: Annotated[Optional[StrictInt], Field(description="Optional. The maximum horizontal resolution of the encoded video.")] = None,
        max_height: Annotated[Optional[StrictInt], Field(description="Optional. The maximum vertical resolution of the encoded video.")] = None,
        video_bit_rate: Annotated[Optional[StrictInt], Field(description="Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.")] = None,
        subtitle_stream_index: Annotated[Optional[StrictInt], Field(description="Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.")] = None,
        subtitle_method: Annotated[Optional[SubtitleDeliveryMethod], Field(description="Optional. Specify the subtitle delivery method.")] = None,
        max_video_bit_depth: Annotated[Optional[StrictInt], Field(description="Optional.")] = None,
        video_codec: Annotated[Optional[StrictStr], Field(description="Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.")] = None,
        audio_stream_index: Annotated[Optional[StrictInt], Field(description="Optional. The index of the audio stream to use. If omitted the first audio stream will be used.")] = None,
        video_stream_index: Annotated[Optional[StrictInt], Field(description="Optional. The index of the video stream to use. If omitted the first video stream will be used.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Gets an audio stream

        Requires authentication as user

        :param stream_file_name: (required)
        :type stream_file_name: str
        :param id: Item Id (required)
        :type id: str
        :param container: Container (required)
        :type container: str
        :param device_profile_id: Optional. The dlna device profile id to utilize.
        :type device_profile_id: str
        :param device_id: The device id of the client requesting. Used to stop encoding processes when needed.
        :type device_id: str
        :param audio_codec: Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
        :type audio_codec: str
        :param enable_auto_stream_copy: Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
        :type enable_auto_stream_copy: bool
        :param audio_sample_rate: Optional. Specify a specific audio sample rate, e.g. 44100
        :type audio_sample_rate: int
        :param audio_bit_rate: Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
        :type audio_bit_rate: int
        :param audio_channels: Optional. Specify a specific number of audio channels to encode to, e.g. 2
        :type audio_channels: int
        :param max_audio_channels: Optional. Specify a maximum number of audio channels to encode to, e.g. 2
        :type max_audio_channels: int
        :param static: Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
        :type static: bool
        :param copy_timestamps: Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
        :type copy_timestamps: bool
        :param start_time_ticks: Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
        :type start_time_ticks: int
        :param width: Optional. The fixed horizontal resolution of the encoded video.
        :type width: int
        :param height: Optional. The fixed vertical resolution of the encoded video.
        :type height: int
        :param max_width: Optional. The maximum horizontal resolution of the encoded video.
        :type max_width: int
        :param max_height: Optional. The maximum vertical resolution of the encoded video.
        :type max_height: int
        :param video_bit_rate: Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
        :type video_bit_rate: int
        :param subtitle_stream_index: Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
        :type subtitle_stream_index: int
        :param subtitle_method: Optional. Specify the subtitle delivery method.
        :type subtitle_method: SubtitleDeliveryMethod
        :param max_video_bit_depth: Optional.
        :type max_video_bit_depth: int
        :param video_codec: Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
        :type video_codec: str
        :param audio_stream_index: Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
        :type audio_stream_index: int
        :param video_stream_index: Optional. The index of the video stream to use. If omitted the first video stream will be used.
        :type video_stream_index: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_audio_by_id_by_streamfilename_serialize(
            stream_file_name=stream_file_name,
            id=id,
            container=container,
            device_profile_id=device_profile_id,
            device_id=device_id,
            audio_codec=audio_codec,
            enable_auto_stream_copy=enable_auto_stream_copy,
            audio_sample_rate=audio_sample_rate,
            audio_bit_rate=audio_bit_rate,
            audio_channels=audio_channels,
            max_audio_channels=max_audio_channels,
            static=static,
            copy_timestamps=copy_timestamps,
            start_time_ticks=start_time_ticks,
            width=width,
            height=height,
            max_width=max_width,
            max_height=max_height,
            video_bit_rate=video_bit_rate,
            subtitle_stream_index=subtitle_stream_index,
            subtitle_method=subtitle_method,
            max_video_bit_depth=max_video_bit_depth,
            video_codec=video_codec,
            audio_stream_index=audio_stream_index,
            video_stream_index=video_stream_index,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '400': None,
            '401': None,
            '403': None,
            '404': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_audio_by_id_by_streamfilename_without_preload_content(
        self,
        stream_file_name: StrictStr,
        id: Annotated[StrictStr, Field(description="Item Id")],
        container: Annotated[StrictStr, Field(description="Container")],
        device_profile_id: Annotated[Optional[StrictStr], Field(description="Optional. The dlna device profile id to utilize.")] = None,
        device_id: Annotated[Optional[StrictStr], Field(description="The device id of the client requesting. Used to stop encoding processes when needed.")] = None,
        audio_codec: Annotated[Optional[StrictStr], Field(description="Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.")] = None,
        enable_auto_stream_copy: Annotated[Optional[StrictBool], Field(description="Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.")] = None,
        audio_sample_rate: Annotated[Optional[StrictInt], Field(description="Optional. Specify a specific audio sample rate, e.g. 44100")] = None,
        audio_bit_rate: Annotated[Optional[StrictInt], Field(description="Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.")] = None,
        audio_channels: Annotated[Optional[StrictInt], Field(description="Optional. Specify a specific number of audio channels to encode to, e.g. 2")] = None,
        max_audio_channels: Annotated[Optional[StrictInt], Field(description="Optional. Specify a maximum number of audio channels to encode to, e.g. 2")] = None,
        static: Annotated[Optional[StrictBool], Field(description="Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false")] = None,
        copy_timestamps: Annotated[Optional[StrictBool], Field(description="Whether or not to copy timestamps when transcoding with an offset. Defaults to false.")] = None,
        start_time_ticks: Annotated[Optional[StrictInt], Field(description="Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.")] = None,
        width: Annotated[Optional[StrictInt], Field(description="Optional. The fixed horizontal resolution of the encoded video.")] = None,
        height: Annotated[Optional[StrictInt], Field(description="Optional. The fixed vertical resolution of the encoded video.")] = None,
        max_width: Annotated[Optional[StrictInt], Field(description="Optional. The maximum horizontal resolution of the encoded video.")] = None,
        max_height: Annotated[Optional[StrictInt], Field(description="Optional. The maximum vertical resolution of the encoded video.")] = None,
        video_bit_rate: Annotated[Optional[StrictInt], Field(description="Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.")] = None,
        subtitle_stream_index: Annotated[Optional[StrictInt], Field(description="Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.")] = None,
        subtitle_method: Annotated[Optional[SubtitleDeliveryMethod], Field(description="Optional. Specify the subtitle delivery method.")] = None,
        max_video_bit_depth: Annotated[Optional[StrictInt], Field(description="Optional.")] = None,
        video_codec: Annotated[Optional[StrictStr], Field(description="Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.")] = None,
        audio_stream_index: Annotated[Optional[StrictInt], Field(description="Optional. The index of the audio stream to use. If omitted the first audio stream will be used.")] = None,
        video_stream_index: Annotated[Optional[StrictInt], Field(description="Optional. The index of the video stream to use. If omitted the first video stream will be used.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Gets an audio stream

        Requires authentication as user

        :param stream_file_name: (required)
        :type stream_file_name: str
        :param id: Item Id (required)
        :type id: str
        :param container: Container (required)
        :type container: str
        :param device_profile_id: Optional. The dlna device profile id to utilize.
        :type device_profile_id: str
        :param device_id: The device id of the client requesting. Used to stop encoding processes when needed.
        :type device_id: str
        :param audio_codec: Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
        :type audio_codec: str
        :param enable_auto_stream_copy: Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
        :type enable_auto_stream_copy: bool
        :param audio_sample_rate: Optional. Specify a specific audio sample rate, e.g. 44100
        :type audio_sample_rate: int
        :param audio_bit_rate: Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
        :type audio_bit_rate: int
        :param audio_channels: Optional. Specify a specific number of audio channels to encode to, e.g. 2
        :type audio_channels: int
        :param max_audio_channels: Optional. Specify a maximum number of audio channels to encode to, e.g. 2
        :type max_audio_channels: int
        :param static: Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
        :type static: bool
        :param copy_timestamps: Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
        :type copy_timestamps: bool
        :param start_time_ticks: Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
        :type start_time_ticks: int
        :param width: Optional. The fixed horizontal resolution of the encoded video.
        :type width: int
        :param height: Optional. The fixed vertical resolution of the encoded video.
        :type height: int
        :param max_width: Optional. The maximum horizontal resolution of the encoded video.
        :type max_width: int
        :param max_height: Optional. The maximum vertical resolution of the encoded video.
        :type max_height: int
        :param video_bit_rate: Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
        :type video_bit_rate: int
        :param subtitle_stream_index: Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
        :type subtitle_stream_index: int
        :param subtitle_method: Optional. Specify the subtitle delivery method.
        :type subtitle_method: SubtitleDeliveryMethod
        :param max_video_bit_depth: Optional.
        :type max_video_bit_depth: int
        :param video_codec: Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
        :type video_codec: str
        :param audio_stream_index: Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
        :type audio_stream_index: int
        :param video_stream_index: Optional. The index of the video stream to use. If omitted the first video stream will be used.
        :type video_stream_index: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_audio_by_id_by_streamfilename_serialize(
            stream_file_name=stream_file_name,
            id=id,
            container=container,
            device_profile_id=device_profile_id,
            device_id=device_id,
            audio_codec=audio_codec,
            enable_auto_stream_copy=enable_auto_stream_copy,
            audio_sample_rate=audio_sample_rate,
            audio_bit_rate=audio_bit_rate,
            audio_channels=audio_channels,
            max_audio_channels=max_audio_channels,
            static=static,
            copy_timestamps=copy_timestamps,
            start_time_ticks=start_time_ticks,
            width=width,
            height=height,
            max_width=max_width,
            max_height=max_height,
            video_bit_rate=video_bit_rate,
            subtitle_stream_index=subtitle_stream_index,
            subtitle_method=subtitle_method,
            max_video_bit_depth=max_video_bit_depth,
            video_codec=video_codec,
            audio_stream_index=audio_stream_index,
            video_stream_index=video_stream_index,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '400': None,
            '401': None,
            '403': None,
            '404': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_audio_by_id_by_streamfilename_serialize(
        self,
        stream_file_name,
        id,
        container,
        device_profile_id,
        device_id,
        audio_codec,
        enable_auto_stream_copy,
        audio_sample_rate,
        audio_bit_rate,
        audio_channels,
        max_audio_channels,
        static,
        copy_timestamps,
        start_time_ticks,
        width,
        height,
        max_width,
        max_height,
        video_bit_rate,
        subtitle_stream_index,
        subtitle_method,
        max_video_bit_depth,
        video_codec,
        audio_stream_index,
        video_stream_index,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if stream_file_name is not None:
            _path_params['StreamFileName'] = stream_file_name
        if id is not None:
            _path_params['Id'] = id
        # process the query parameters
        if device_profile_id is not None:
            
            _query_params.append(('DeviceProfileId', device_profile_id))
            
        if device_id is not None:
            
            _query_params.append(('DeviceId', device_id))
            
        if container is not None:
            
            _query_params.append(('Container', container))
            
        if audio_codec is not None:
            
            _query_params.append(('AudioCodec', audio_codec))
            
        if enable_auto_stream_copy is not None:
            
            _query_params.append(('EnableAutoStreamCopy', enable_auto_stream_copy))
            
        if audio_sample_rate is not None:
            
            _query_params.append(('AudioSampleRate', audio_sample_rate))
            
        if audio_bit_rate is not None:
            
            _query_params.append(('AudioBitRate', audio_bit_rate))
            
        if audio_channels is not None:
            
            _query_params.append(('AudioChannels', audio_channels))
            
        if max_audio_channels is not None:
            
            _query_params.append(('MaxAudioChannels', max_audio_channels))
            
        if static is not None:
            
            _query_params.append(('Static', static))
            
        if copy_timestamps is not None:
            
            _query_params.append(('CopyTimestamps', copy_timestamps))
            
        if start_time_ticks is not None:
            
            _query_params.append(('StartTimeTicks', start_time_ticks))
            
        if width is not None:
            
            _query_params.append(('Width', width))
            
        if height is not None:
            
            _query_params.append(('Height', height))
            
        if max_width is not None:
            
            _query_params.append(('MaxWidth', max_width))
            
        if max_height is not None:
            
            _query_params.append(('MaxHeight', max_height))
            
        if video_bit_rate is not None:
            
            _query_params.append(('VideoBitRate', video_bit_rate))
            
        if subtitle_stream_index is not None:
            
            _query_params.append(('SubtitleStreamIndex', subtitle_stream_index))
            
        if subtitle_method is not None:
            
            _query_params.append(('SubtitleMethod', subtitle_method.value))
            
        if max_video_bit_depth is not None:
            
            _query_params.append(('MaxVideoBitDepth', max_video_bit_depth))
            
        if video_codec is not None:
            
            _query_params.append(('VideoCodec', video_codec))
            
        if audio_stream_index is not None:
            
            _query_params.append(('AudioStreamIndex', audio_stream_index))
            
        if video_stream_index is not None:
            
            _query_params.append(('VideoStreamIndex', video_stream_index))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
            'apikeyauth', 
            'embyauth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/Audio/{Id}/{StreamFileName}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_audio_by_id_stream(
        self,
        id: Annotated[StrictStr, Field(description="Item Id")],
        container: Annotated[StrictStr, Field(description="Container")],
        device_profile_id: Annotated[Optional[StrictStr], Field(description="Optional. The dlna device profile id to utilize.")] = None,
        device_id: Annotated[Optional[StrictStr], Field(description="The device id of the client requesting. Used to stop encoding processes when needed.")] = None,
        audio_codec: Annotated[Optional[StrictStr], Field(description="Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.")] = None,
        enable_auto_stream_copy: Annotated[Optional[StrictBool], Field(description="Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.")] = None,
        audio_sample_rate: Annotated[Optional[StrictInt], Field(description="Optional. Specify a specific audio sample rate, e.g. 44100")] = None,
        audio_bit_rate: Annotated[Optional[StrictInt], Field(description="Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.")] = None,
        audio_channels: Annotated[Optional[StrictInt], Field(description="Optional. Specify a specific number of audio channels to encode to, e.g. 2")] = None,
        max_audio_channels: Annotated[Optional[StrictInt], Field(description="Optional. Specify a maximum number of audio channels to encode to, e.g. 2")] = None,
        static: Annotated[Optional[StrictBool], Field(description="Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false")] = None,
        copy_timestamps: Annotated[Optional[StrictBool], Field(description="Whether or not to copy timestamps when transcoding with an offset. Defaults to false.")] = None,
        start_time_ticks: Annotated[Optional[StrictInt], Field(description="Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.")] = None,
        width: Annotated[Optional[StrictInt], Field(description="Optional. The fixed horizontal resolution of the encoded video.")] = None,
        height: Annotated[Optional[StrictInt], Field(description="Optional. The fixed vertical resolution of the encoded video.")] = None,
        max_width: Annotated[Optional[StrictInt], Field(description="Optional. The maximum horizontal resolution of the encoded video.")] = None,
        max_height: Annotated[Optional[StrictInt], Field(description="Optional. The maximum vertical resolution of the encoded video.")] = None,
        video_bit_rate: Annotated[Optional[StrictInt], Field(description="Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.")] = None,
        subtitle_stream_index: Annotated[Optional[StrictInt], Field(description="Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.")] = None,
        subtitle_method: Annotated[Optional[SubtitleDeliveryMethod], Field(description="Optional. Specify the subtitle delivery method.")] = None,
        max_video_bit_depth: Annotated[Optional[StrictInt], Field(description="Optional.")] = None,
        video_codec: Annotated[Optional[StrictStr], Field(description="Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.")] = None,
        audio_stream_index: Annotated[Optional[StrictInt], Field(description="Optional. The index of the audio stream to use. If omitted the first audio stream will be used.")] = None,
        video_stream_index: Annotated[Optional[StrictInt], Field(description="Optional. The index of the video stream to use. If omitted the first video stream will be used.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Gets an audio stream

        Requires authentication as user

        :param id: Item Id (required)
        :type id: str
        :param container: Container (required)
        :type container: str
        :param device_profile_id: Optional. The dlna device profile id to utilize.
        :type device_profile_id: str
        :param device_id: The device id of the client requesting. Used to stop encoding processes when needed.
        :type device_id: str
        :param audio_codec: Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
        :type audio_codec: str
        :param enable_auto_stream_copy: Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
        :type enable_auto_stream_copy: bool
        :param audio_sample_rate: Optional. Specify a specific audio sample rate, e.g. 44100
        :type audio_sample_rate: int
        :param audio_bit_rate: Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
        :type audio_bit_rate: int
        :param audio_channels: Optional. Specify a specific number of audio channels to encode to, e.g. 2
        :type audio_channels: int
        :param max_audio_channels: Optional. Specify a maximum number of audio channels to encode to, e.g. 2
        :type max_audio_channels: int
        :param static: Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
        :type static: bool
        :param copy_timestamps: Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
        :type copy_timestamps: bool
        :param start_time_ticks: Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
        :type start_time_ticks: int
        :param width: Optional. The fixed horizontal resolution of the encoded video.
        :type width: int
        :param height: Optional. The fixed vertical resolution of the encoded video.
        :type height: int
        :param max_width: Optional. The maximum horizontal resolution of the encoded video.
        :type max_width: int
        :param max_height: Optional. The maximum vertical resolution of the encoded video.
        :type max_height: int
        :param video_bit_rate: Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
        :type video_bit_rate: int
        :param subtitle_stream_index: Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
        :type subtitle_stream_index: int
        :param subtitle_method: Optional. Specify the subtitle delivery method.
        :type subtitle_method: SubtitleDeliveryMethod
        :param max_video_bit_depth: Optional.
        :type max_video_bit_depth: int
        :param video_codec: Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
        :type video_codec: str
        :param audio_stream_index: Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
        :type audio_stream_index: int
        :param video_stream_index: Optional. The index of the video stream to use. If omitted the first video stream will be used.
        :type video_stream_index: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_audio_by_id_stream_serialize(
            id=id,
            container=container,
            device_profile_id=device_profile_id,
            device_id=device_id,
            audio_codec=audio_codec,
            enable_auto_stream_copy=enable_auto_stream_copy,
            audio_sample_rate=audio_sample_rate,
            audio_bit_rate=audio_bit_rate,
            audio_channels=audio_channels,
            max_audio_channels=max_audio_channels,
            static=static,
            copy_timestamps=copy_timestamps,
            start_time_ticks=start_time_ticks,
            width=width,
            height=height,
            max_width=max_width,
            max_height=max_height,
            video_bit_rate=video_bit_rate,
            subtitle_stream_index=subtitle_stream_index,
            subtitle_method=subtitle_method,
            max_video_bit_depth=max_video_bit_depth,
            video_codec=video_codec,
            audio_stream_index=audio_stream_index,
            video_stream_index=video_stream_index,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '400': None,
            '401': None,
            '403': None,
            '404': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_audio_by_id_stream_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="Item Id")],
        container: Annotated[StrictStr, Field(description="Container")],
        device_profile_id: Annotated[Optional[StrictStr], Field(description="Optional. The dlna device profile id to utilize.")] = None,
        device_id: Annotated[Optional[StrictStr], Field(description="The device id of the client requesting. Used to stop encoding processes when needed.")] = None,
        audio_codec: Annotated[Optional[StrictStr], Field(description="Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.")] = None,
        enable_auto_stream_copy: Annotated[Optional[StrictBool], Field(description="Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.")] = None,
        audio_sample_rate: Annotated[Optional[StrictInt], Field(description="Optional. Specify a specific audio sample rate, e.g. 44100")] = None,
        audio_bit_rate: Annotated[Optional[StrictInt], Field(description="Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.")] = None,
        audio_channels: Annotated[Optional[StrictInt], Field(description="Optional. Specify a specific number of audio channels to encode to, e.g. 2")] = None,
        max_audio_channels: Annotated[Optional[StrictInt], Field(description="Optional. Specify a maximum number of audio channels to encode to, e.g. 2")] = None,
        static: Annotated[Optional[StrictBool], Field(description="Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false")] = None,
        copy_timestamps: Annotated[Optional[StrictBool], Field(description="Whether or not to copy timestamps when transcoding with an offset. Defaults to false.")] = None,
        start_time_ticks: Annotated[Optional[StrictInt], Field(description="Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.")] = None,
        width: Annotated[Optional[StrictInt], Field(description="Optional. The fixed horizontal resolution of the encoded video.")] = None,
        height: Annotated[Optional[StrictInt], Field(description="Optional. The fixed vertical resolution of the encoded video.")] = None,
        max_width: Annotated[Optional[StrictInt], Field(description="Optional. The maximum horizontal resolution of the encoded video.")] = None,
        max_height: Annotated[Optional[StrictInt], Field(description="Optional. The maximum vertical resolution of the encoded video.")] = None,
        video_bit_rate: Annotated[Optional[StrictInt], Field(description="Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.")] = None,
        subtitle_stream_index: Annotated[Optional[StrictInt], Field(description="Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.")] = None,
        subtitle_method: Annotated[Optional[SubtitleDeliveryMethod], Field(description="Optional. Specify the subtitle delivery method.")] = None,
        max_video_bit_depth: Annotated[Optional[StrictInt], Field(description="Optional.")] = None,
        video_codec: Annotated[Optional[StrictStr], Field(description="Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.")] = None,
        audio_stream_index: Annotated[Optional[StrictInt], Field(description="Optional. The index of the audio stream to use. If omitted the first audio stream will be used.")] = None,
        video_stream_index: Annotated[Optional[StrictInt], Field(description="Optional. The index of the video stream to use. If omitted the first video stream will be used.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Gets an audio stream

        Requires authentication as user

        :param id: Item Id (required)
        :type id: str
        :param container: Container (required)
        :type container: str
        :param device_profile_id: Optional. The dlna device profile id to utilize.
        :type device_profile_id: str
        :param device_id: The device id of the client requesting. Used to stop encoding processes when needed.
        :type device_id: str
        :param audio_codec: Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
        :type audio_codec: str
        :param enable_auto_stream_copy: Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
        :type enable_auto_stream_copy: bool
        :param audio_sample_rate: Optional. Specify a specific audio sample rate, e.g. 44100
        :type audio_sample_rate: int
        :param audio_bit_rate: Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
        :type audio_bit_rate: int
        :param audio_channels: Optional. Specify a specific number of audio channels to encode to, e.g. 2
        :type audio_channels: int
        :param max_audio_channels: Optional. Specify a maximum number of audio channels to encode to, e.g. 2
        :type max_audio_channels: int
        :param static: Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
        :type static: bool
        :param copy_timestamps: Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
        :type copy_timestamps: bool
        :param start_time_ticks: Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
        :type start_time_ticks: int
        :param width: Optional. The fixed horizontal resolution of the encoded video.
        :type width: int
        :param height: Optional. The fixed vertical resolution of the encoded video.
        :type height: int
        :param max_width: Optional. The maximum horizontal resolution of the encoded video.
        :type max_width: int
        :param max_height: Optional. The maximum vertical resolution of the encoded video.
        :type max_height: int
        :param video_bit_rate: Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
        :type video_bit_rate: int
        :param subtitle_stream_index: Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
        :type subtitle_stream_index: int
        :param subtitle_method: Optional. Specify the subtitle delivery method.
        :type subtitle_method: SubtitleDeliveryMethod
        :param max_video_bit_depth: Optional.
        :type max_video_bit_depth: int
        :param video_codec: Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
        :type video_codec: str
        :param audio_stream_index: Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
        :type audio_stream_index: int
        :param video_stream_index: Optional. The index of the video stream to use. If omitted the first video stream will be used.
        :type video_stream_index: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_audio_by_id_stream_serialize(
            id=id,
            container=container,
            device_profile_id=device_profile_id,
            device_id=device_id,
            audio_codec=audio_codec,
            enable_auto_stream_copy=enable_auto_stream_copy,
            audio_sample_rate=audio_sample_rate,
            audio_bit_rate=audio_bit_rate,
            audio_channels=audio_channels,
            max_audio_channels=max_audio_channels,
            static=static,
            copy_timestamps=copy_timestamps,
            start_time_ticks=start_time_ticks,
            width=width,
            height=height,
            max_width=max_width,
            max_height=max_height,
            video_bit_rate=video_bit_rate,
            subtitle_stream_index=subtitle_stream_index,
            subtitle_method=subtitle_method,
            max_video_bit_depth=max_video_bit_depth,
            video_codec=video_codec,
            audio_stream_index=audio_stream_index,
            video_stream_index=video_stream_index,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '400': None,
            '401': None,
            '403': None,
            '404': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_audio_by_id_stream_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="Item Id")],
        container: Annotated[StrictStr, Field(description="Container")],
        device_profile_id: Annotated[Optional[StrictStr], Field(description="Optional. The dlna device profile id to utilize.")] = None,
        device_id: Annotated[Optional[StrictStr], Field(description="The device id of the client requesting. Used to stop encoding processes when needed.")] = None,
        audio_codec: Annotated[Optional[StrictStr], Field(description="Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.")] = None,
        enable_auto_stream_copy: Annotated[Optional[StrictBool], Field(description="Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.")] = None,
        audio_sample_rate: Annotated[Optional[StrictInt], Field(description="Optional. Specify a specific audio sample rate, e.g. 44100")] = None,
        audio_bit_rate: Annotated[Optional[StrictInt], Field(description="Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.")] = None,
        audio_channels: Annotated[Optional[StrictInt], Field(description="Optional. Specify a specific number of audio channels to encode to, e.g. 2")] = None,
        max_audio_channels: Annotated[Optional[StrictInt], Field(description="Optional. Specify a maximum number of audio channels to encode to, e.g. 2")] = None,
        static: Annotated[Optional[StrictBool], Field(description="Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false")] = None,
        copy_timestamps: Annotated[Optional[StrictBool], Field(description="Whether or not to copy timestamps when transcoding with an offset. Defaults to false.")] = None,
        start_time_ticks: Annotated[Optional[StrictInt], Field(description="Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.")] = None,
        width: Annotated[Optional[StrictInt], Field(description="Optional. The fixed horizontal resolution of the encoded video.")] = None,
        height: Annotated[Optional[StrictInt], Field(description="Optional. The fixed vertical resolution of the encoded video.")] = None,
        max_width: Annotated[Optional[StrictInt], Field(description="Optional. The maximum horizontal resolution of the encoded video.")] = None,
        max_height: Annotated[Optional[StrictInt], Field(description="Optional. The maximum vertical resolution of the encoded video.")] = None,
        video_bit_rate: Annotated[Optional[StrictInt], Field(description="Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.")] = None,
        subtitle_stream_index: Annotated[Optional[StrictInt], Field(description="Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.")] = None,
        subtitle_method: Annotated[Optional[SubtitleDeliveryMethod], Field(description="Optional. Specify the subtitle delivery method.")] = None,
        max_video_bit_depth: Annotated[Optional[StrictInt], Field(description="Optional.")] = None,
        video_codec: Annotated[Optional[StrictStr], Field(description="Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.")] = None,
        audio_stream_index: Annotated[Optional[StrictInt], Field(description="Optional. The index of the audio stream to use. If omitted the first audio stream will be used.")] = None,
        video_stream_index: Annotated[Optional[StrictInt], Field(description="Optional. The index of the video stream to use. If omitted the first video stream will be used.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Gets an audio stream

        Requires authentication as user

        :param id: Item Id (required)
        :type id: str
        :param container: Container (required)
        :type container: str
        :param device_profile_id: Optional. The dlna device profile id to utilize.
        :type device_profile_id: str
        :param device_id: The device id of the client requesting. Used to stop encoding processes when needed.
        :type device_id: str
        :param audio_codec: Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
        :type audio_codec: str
        :param enable_auto_stream_copy: Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
        :type enable_auto_stream_copy: bool
        :param audio_sample_rate: Optional. Specify a specific audio sample rate, e.g. 44100
        :type audio_sample_rate: int
        :param audio_bit_rate: Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
        :type audio_bit_rate: int
        :param audio_channels: Optional. Specify a specific number of audio channels to encode to, e.g. 2
        :type audio_channels: int
        :param max_audio_channels: Optional. Specify a maximum number of audio channels to encode to, e.g. 2
        :type max_audio_channels: int
        :param static: Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
        :type static: bool
        :param copy_timestamps: Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
        :type copy_timestamps: bool
        :param start_time_ticks: Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
        :type start_time_ticks: int
        :param width: Optional. The fixed horizontal resolution of the encoded video.
        :type width: int
        :param height: Optional. The fixed vertical resolution of the encoded video.
        :type height: int
        :param max_width: Optional. The maximum horizontal resolution of the encoded video.
        :type max_width: int
        :param max_height: Optional. The maximum vertical resolution of the encoded video.
        :type max_height: int
        :param video_bit_rate: Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
        :type video_bit_rate: int
        :param subtitle_stream_index: Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
        :type subtitle_stream_index: int
        :param subtitle_method: Optional. Specify the subtitle delivery method.
        :type subtitle_method: SubtitleDeliveryMethod
        :param max_video_bit_depth: Optional.
        :type max_video_bit_depth: int
        :param video_codec: Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
        :type video_codec: str
        :param audio_stream_index: Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
        :type audio_stream_index: int
        :param video_stream_index: Optional. The index of the video stream to use. If omitted the first video stream will be used.
        :type video_stream_index: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_audio_by_id_stream_serialize(
            id=id,
            container=container,
            device_profile_id=device_profile_id,
            device_id=device_id,
            audio_codec=audio_codec,
            enable_auto_stream_copy=enable_auto_stream_copy,
            audio_sample_rate=audio_sample_rate,
            audio_bit_rate=audio_bit_rate,
            audio_channels=audio_channels,
            max_audio_channels=max_audio_channels,
            static=static,
            copy_timestamps=copy_timestamps,
            start_time_ticks=start_time_ticks,
            width=width,
            height=height,
            max_width=max_width,
            max_height=max_height,
            video_bit_rate=video_bit_rate,
            subtitle_stream_index=subtitle_stream_index,
            subtitle_method=subtitle_method,
            max_video_bit_depth=max_video_bit_depth,
            video_codec=video_codec,
            audio_stream_index=audio_stream_index,
            video_stream_index=video_stream_index,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '400': None,
            '401': None,
            '403': None,
            '404': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_audio_by_id_stream_serialize(
        self,
        id,
        container,
        device_profile_id,
        device_id,
        audio_codec,
        enable_auto_stream_copy,
        audio_sample_rate,
        audio_bit_rate,
        audio_channels,
        max_audio_channels,
        static,
        copy_timestamps,
        start_time_ticks,
        width,
        height,
        max_width,
        max_height,
        video_bit_rate,
        subtitle_stream_index,
        subtitle_method,
        max_video_bit_depth,
        video_codec,
        audio_stream_index,
        video_stream_index,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['Id'] = id
        # process the query parameters
        if device_profile_id is not None:
            
            _query_params.append(('DeviceProfileId', device_profile_id))
            
        if device_id is not None:
            
            _query_params.append(('DeviceId', device_id))
            
        if container is not None:
            
            _query_params.append(('Container', container))
            
        if audio_codec is not None:
            
            _query_params.append(('AudioCodec', audio_codec))
            
        if enable_auto_stream_copy is not None:
            
            _query_params.append(('EnableAutoStreamCopy', enable_auto_stream_copy))
            
        if audio_sample_rate is not None:
            
            _query_params.append(('AudioSampleRate', audio_sample_rate))
            
        if audio_bit_rate is not None:
            
            _query_params.append(('AudioBitRate', audio_bit_rate))
            
        if audio_channels is not None:
            
            _query_params.append(('AudioChannels', audio_channels))
            
        if max_audio_channels is not None:
            
            _query_params.append(('MaxAudioChannels', max_audio_channels))
            
        if static is not None:
            
            _query_params.append(('Static', static))
            
        if copy_timestamps is not None:
            
            _query_params.append(('CopyTimestamps', copy_timestamps))
            
        if start_time_ticks is not None:
            
            _query_params.append(('StartTimeTicks', start_time_ticks))
            
        if width is not None:
            
            _query_params.append(('Width', width))
            
        if height is not None:
            
            _query_params.append(('Height', height))
            
        if max_width is not None:
            
            _query_params.append(('MaxWidth', max_width))
            
        if max_height is not None:
            
            _query_params.append(('MaxHeight', max_height))
            
        if video_bit_rate is not None:
            
            _query_params.append(('VideoBitRate', video_bit_rate))
            
        if subtitle_stream_index is not None:
            
            _query_params.append(('SubtitleStreamIndex', subtitle_stream_index))
            
        if subtitle_method is not None:
            
            _query_params.append(('SubtitleMethod', subtitle_method.value))
            
        if max_video_bit_depth is not None:
            
            _query_params.append(('MaxVideoBitDepth', max_video_bit_depth))
            
        if video_codec is not None:
            
            _query_params.append(('VideoCodec', video_codec))
            
        if audio_stream_index is not None:
            
            _query_params.append(('AudioStreamIndex', audio_stream_index))
            
        if video_stream_index is not None:
            
            _query_params.append(('VideoStreamIndex', video_stream_index))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
            'apikeyauth', 
            'embyauth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/Audio/{Id}/stream',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_audio_by_id_stream_by_container(
        self,
        id: Annotated[StrictStr, Field(description="Item Id")],
        container: Annotated[StrictStr, Field(description="Container")],
        device_profile_id: Annotated[Optional[StrictStr], Field(description="Optional. The dlna device profile id to utilize.")] = None,
        device_id: Annotated[Optional[StrictStr], Field(description="The device id of the client requesting. Used to stop encoding processes when needed.")] = None,
        audio_codec: Annotated[Optional[StrictStr], Field(description="Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.")] = None,
        enable_auto_stream_copy: Annotated[Optional[StrictBool], Field(description="Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.")] = None,
        audio_sample_rate: Annotated[Optional[StrictInt], Field(description="Optional. Specify a specific audio sample rate, e.g. 44100")] = None,
        audio_bit_rate: Annotated[Optional[StrictInt], Field(description="Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.")] = None,
        audio_channels: Annotated[Optional[StrictInt], Field(description="Optional. Specify a specific number of audio channels to encode to, e.g. 2")] = None,
        max_audio_channels: Annotated[Optional[StrictInt], Field(description="Optional. Specify a maximum number of audio channels to encode to, e.g. 2")] = None,
        static: Annotated[Optional[StrictBool], Field(description="Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false")] = None,
        copy_timestamps: Annotated[Optional[StrictBool], Field(description="Whether or not to copy timestamps when transcoding with an offset. Defaults to false.")] = None,
        start_time_ticks: Annotated[Optional[StrictInt], Field(description="Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.")] = None,
        width: Annotated[Optional[StrictInt], Field(description="Optional. The fixed horizontal resolution of the encoded video.")] = None,
        height: Annotated[Optional[StrictInt], Field(description="Optional. The fixed vertical resolution of the encoded video.")] = None,
        max_width: Annotated[Optional[StrictInt], Field(description="Optional. The maximum horizontal resolution of the encoded video.")] = None,
        max_height: Annotated[Optional[StrictInt], Field(description="Optional. The maximum vertical resolution of the encoded video.")] = None,
        video_bit_rate: Annotated[Optional[StrictInt], Field(description="Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.")] = None,
        subtitle_stream_index: Annotated[Optional[StrictInt], Field(description="Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.")] = None,
        subtitle_method: Annotated[Optional[SubtitleDeliveryMethod], Field(description="Optional. Specify the subtitle delivery method.")] = None,
        max_video_bit_depth: Annotated[Optional[StrictInt], Field(description="Optional.")] = None,
        video_codec: Annotated[Optional[StrictStr], Field(description="Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.")] = None,
        audio_stream_index: Annotated[Optional[StrictInt], Field(description="Optional. The index of the audio stream to use. If omitted the first audio stream will be used.")] = None,
        video_stream_index: Annotated[Optional[StrictInt], Field(description="Optional. The index of the video stream to use. If omitted the first video stream will be used.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Gets an audio stream

        Requires authentication as user

        :param id: Item Id (required)
        :type id: str
        :param container: Container (required)
        :type container: str
        :param device_profile_id: Optional. The dlna device profile id to utilize.
        :type device_profile_id: str
        :param device_id: The device id of the client requesting. Used to stop encoding processes when needed.
        :type device_id: str
        :param audio_codec: Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
        :type audio_codec: str
        :param enable_auto_stream_copy: Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
        :type enable_auto_stream_copy: bool
        :param audio_sample_rate: Optional. Specify a specific audio sample rate, e.g. 44100
        :type audio_sample_rate: int
        :param audio_bit_rate: Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
        :type audio_bit_rate: int
        :param audio_channels: Optional. Specify a specific number of audio channels to encode to, e.g. 2
        :type audio_channels: int
        :param max_audio_channels: Optional. Specify a maximum number of audio channels to encode to, e.g. 2
        :type max_audio_channels: int
        :param static: Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
        :type static: bool
        :param copy_timestamps: Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
        :type copy_timestamps: bool
        :param start_time_ticks: Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
        :type start_time_ticks: int
        :param width: Optional. The fixed horizontal resolution of the encoded video.
        :type width: int
        :param height: Optional. The fixed vertical resolution of the encoded video.
        :type height: int
        :param max_width: Optional. The maximum horizontal resolution of the encoded video.
        :type max_width: int
        :param max_height: Optional. The maximum vertical resolution of the encoded video.
        :type max_height: int
        :param video_bit_rate: Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
        :type video_bit_rate: int
        :param subtitle_stream_index: Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
        :type subtitle_stream_index: int
        :param subtitle_method: Optional. Specify the subtitle delivery method.
        :type subtitle_method: SubtitleDeliveryMethod
        :param max_video_bit_depth: Optional.
        :type max_video_bit_depth: int
        :param video_codec: Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
        :type video_codec: str
        :param audio_stream_index: Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
        :type audio_stream_index: int
        :param video_stream_index: Optional. The index of the video stream to use. If omitted the first video stream will be used.
        :type video_stream_index: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_audio_by_id_stream_by_container_serialize(
            id=id,
            container=container,
            device_profile_id=device_profile_id,
            device_id=device_id,
            audio_codec=audio_codec,
            enable_auto_stream_copy=enable_auto_stream_copy,
            audio_sample_rate=audio_sample_rate,
            audio_bit_rate=audio_bit_rate,
            audio_channels=audio_channels,
            max_audio_channels=max_audio_channels,
            static=static,
            copy_timestamps=copy_timestamps,
            start_time_ticks=start_time_ticks,
            width=width,
            height=height,
            max_width=max_width,
            max_height=max_height,
            video_bit_rate=video_bit_rate,
            subtitle_stream_index=subtitle_stream_index,
            subtitle_method=subtitle_method,
            max_video_bit_depth=max_video_bit_depth,
            video_codec=video_codec,
            audio_stream_index=audio_stream_index,
            video_stream_index=video_stream_index,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '400': None,
            '401': None,
            '403': None,
            '404': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_audio_by_id_stream_by_container_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="Item Id")],
        container: Annotated[StrictStr, Field(description="Container")],
        device_profile_id: Annotated[Optional[StrictStr], Field(description="Optional. The dlna device profile id to utilize.")] = None,
        device_id: Annotated[Optional[StrictStr], Field(description="The device id of the client requesting. Used to stop encoding processes when needed.")] = None,
        audio_codec: Annotated[Optional[StrictStr], Field(description="Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.")] = None,
        enable_auto_stream_copy: Annotated[Optional[StrictBool], Field(description="Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.")] = None,
        audio_sample_rate: Annotated[Optional[StrictInt], Field(description="Optional. Specify a specific audio sample rate, e.g. 44100")] = None,
        audio_bit_rate: Annotated[Optional[StrictInt], Field(description="Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.")] = None,
        audio_channels: Annotated[Optional[StrictInt], Field(description="Optional. Specify a specific number of audio channels to encode to, e.g. 2")] = None,
        max_audio_channels: Annotated[Optional[StrictInt], Field(description="Optional. Specify a maximum number of audio channels to encode to, e.g. 2")] = None,
        static: Annotated[Optional[StrictBool], Field(description="Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false")] = None,
        copy_timestamps: Annotated[Optional[StrictBool], Field(description="Whether or not to copy timestamps when transcoding with an offset. Defaults to false.")] = None,
        start_time_ticks: Annotated[Optional[StrictInt], Field(description="Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.")] = None,
        width: Annotated[Optional[StrictInt], Field(description="Optional. The fixed horizontal resolution of the encoded video.")] = None,
        height: Annotated[Optional[StrictInt], Field(description="Optional. The fixed vertical resolution of the encoded video.")] = None,
        max_width: Annotated[Optional[StrictInt], Field(description="Optional. The maximum horizontal resolution of the encoded video.")] = None,
        max_height: Annotated[Optional[StrictInt], Field(description="Optional. The maximum vertical resolution of the encoded video.")] = None,
        video_bit_rate: Annotated[Optional[StrictInt], Field(description="Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.")] = None,
        subtitle_stream_index: Annotated[Optional[StrictInt], Field(description="Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.")] = None,
        subtitle_method: Annotated[Optional[SubtitleDeliveryMethod], Field(description="Optional. Specify the subtitle delivery method.")] = None,
        max_video_bit_depth: Annotated[Optional[StrictInt], Field(description="Optional.")] = None,
        video_codec: Annotated[Optional[StrictStr], Field(description="Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.")] = None,
        audio_stream_index: Annotated[Optional[StrictInt], Field(description="Optional. The index of the audio stream to use. If omitted the first audio stream will be used.")] = None,
        video_stream_index: Annotated[Optional[StrictInt], Field(description="Optional. The index of the video stream to use. If omitted the first video stream will be used.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Gets an audio stream

        Requires authentication as user

        :param id: Item Id (required)
        :type id: str
        :param container: Container (required)
        :type container: str
        :param device_profile_id: Optional. The dlna device profile id to utilize.
        :type device_profile_id: str
        :param device_id: The device id of the client requesting. Used to stop encoding processes when needed.
        :type device_id: str
        :param audio_codec: Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
        :type audio_codec: str
        :param enable_auto_stream_copy: Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
        :type enable_auto_stream_copy: bool
        :param audio_sample_rate: Optional. Specify a specific audio sample rate, e.g. 44100
        :type audio_sample_rate: int
        :param audio_bit_rate: Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
        :type audio_bit_rate: int
        :param audio_channels: Optional. Specify a specific number of audio channels to encode to, e.g. 2
        :type audio_channels: int
        :param max_audio_channels: Optional. Specify a maximum number of audio channels to encode to, e.g. 2
        :type max_audio_channels: int
        :param static: Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
        :type static: bool
        :param copy_timestamps: Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
        :type copy_timestamps: bool
        :param start_time_ticks: Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
        :type start_time_ticks: int
        :param width: Optional. The fixed horizontal resolution of the encoded video.
        :type width: int
        :param height: Optional. The fixed vertical resolution of the encoded video.
        :type height: int
        :param max_width: Optional. The maximum horizontal resolution of the encoded video.
        :type max_width: int
        :param max_height: Optional. The maximum vertical resolution of the encoded video.
        :type max_height: int
        :param video_bit_rate: Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
        :type video_bit_rate: int
        :param subtitle_stream_index: Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
        :type subtitle_stream_index: int
        :param subtitle_method: Optional. Specify the subtitle delivery method.
        :type subtitle_method: SubtitleDeliveryMethod
        :param max_video_bit_depth: Optional.
        :type max_video_bit_depth: int
        :param video_codec: Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
        :type video_codec: str
        :param audio_stream_index: Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
        :type audio_stream_index: int
        :param video_stream_index: Optional. The index of the video stream to use. If omitted the first video stream will be used.
        :type video_stream_index: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_audio_by_id_stream_by_container_serialize(
            id=id,
            container=container,
            device_profile_id=device_profile_id,
            device_id=device_id,
            audio_codec=audio_codec,
            enable_auto_stream_copy=enable_auto_stream_copy,
            audio_sample_rate=audio_sample_rate,
            audio_bit_rate=audio_bit_rate,
            audio_channels=audio_channels,
            max_audio_channels=max_audio_channels,
            static=static,
            copy_timestamps=copy_timestamps,
            start_time_ticks=start_time_ticks,
            width=width,
            height=height,
            max_width=max_width,
            max_height=max_height,
            video_bit_rate=video_bit_rate,
            subtitle_stream_index=subtitle_stream_index,
            subtitle_method=subtitle_method,
            max_video_bit_depth=max_video_bit_depth,
            video_codec=video_codec,
            audio_stream_index=audio_stream_index,
            video_stream_index=video_stream_index,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '400': None,
            '401': None,
            '403': None,
            '404': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_audio_by_id_stream_by_container_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="Item Id")],
        container: Annotated[StrictStr, Field(description="Container")],
        device_profile_id: Annotated[Optional[StrictStr], Field(description="Optional. The dlna device profile id to utilize.")] = None,
        device_id: Annotated[Optional[StrictStr], Field(description="The device id of the client requesting. Used to stop encoding processes when needed.")] = None,
        audio_codec: Annotated[Optional[StrictStr], Field(description="Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.")] = None,
        enable_auto_stream_copy: Annotated[Optional[StrictBool], Field(description="Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.")] = None,
        audio_sample_rate: Annotated[Optional[StrictInt], Field(description="Optional. Specify a specific audio sample rate, e.g. 44100")] = None,
        audio_bit_rate: Annotated[Optional[StrictInt], Field(description="Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.")] = None,
        audio_channels: Annotated[Optional[StrictInt], Field(description="Optional. Specify a specific number of audio channels to encode to, e.g. 2")] = None,
        max_audio_channels: Annotated[Optional[StrictInt], Field(description="Optional. Specify a maximum number of audio channels to encode to, e.g. 2")] = None,
        static: Annotated[Optional[StrictBool], Field(description="Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false")] = None,
        copy_timestamps: Annotated[Optional[StrictBool], Field(description="Whether or not to copy timestamps when transcoding with an offset. Defaults to false.")] = None,
        start_time_ticks: Annotated[Optional[StrictInt], Field(description="Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.")] = None,
        width: Annotated[Optional[StrictInt], Field(description="Optional. The fixed horizontal resolution of the encoded video.")] = None,
        height: Annotated[Optional[StrictInt], Field(description="Optional. The fixed vertical resolution of the encoded video.")] = None,
        max_width: Annotated[Optional[StrictInt], Field(description="Optional. The maximum horizontal resolution of the encoded video.")] = None,
        max_height: Annotated[Optional[StrictInt], Field(description="Optional. The maximum vertical resolution of the encoded video.")] = None,
        video_bit_rate: Annotated[Optional[StrictInt], Field(description="Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.")] = None,
        subtitle_stream_index: Annotated[Optional[StrictInt], Field(description="Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.")] = None,
        subtitle_method: Annotated[Optional[SubtitleDeliveryMethod], Field(description="Optional. Specify the subtitle delivery method.")] = None,
        max_video_bit_depth: Annotated[Optional[StrictInt], Field(description="Optional.")] = None,
        video_codec: Annotated[Optional[StrictStr], Field(description="Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.")] = None,
        audio_stream_index: Annotated[Optional[StrictInt], Field(description="Optional. The index of the audio stream to use. If omitted the first audio stream will be used.")] = None,
        video_stream_index: Annotated[Optional[StrictInt], Field(description="Optional. The index of the video stream to use. If omitted the first video stream will be used.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Gets an audio stream

        Requires authentication as user

        :param id: Item Id (required)
        :type id: str
        :param container: Container (required)
        :type container: str
        :param device_profile_id: Optional. The dlna device profile id to utilize.
        :type device_profile_id: str
        :param device_id: The device id of the client requesting. Used to stop encoding processes when needed.
        :type device_id: str
        :param audio_codec: Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
        :type audio_codec: str
        :param enable_auto_stream_copy: Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
        :type enable_auto_stream_copy: bool
        :param audio_sample_rate: Optional. Specify a specific audio sample rate, e.g. 44100
        :type audio_sample_rate: int
        :param audio_bit_rate: Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
        :type audio_bit_rate: int
        :param audio_channels: Optional. Specify a specific number of audio channels to encode to, e.g. 2
        :type audio_channels: int
        :param max_audio_channels: Optional. Specify a maximum number of audio channels to encode to, e.g. 2
        :type max_audio_channels: int
        :param static: Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
        :type static: bool
        :param copy_timestamps: Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
        :type copy_timestamps: bool
        :param start_time_ticks: Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
        :type start_time_ticks: int
        :param width: Optional. The fixed horizontal resolution of the encoded video.
        :type width: int
        :param height: Optional. The fixed vertical resolution of the encoded video.
        :type height: int
        :param max_width: Optional. The maximum horizontal resolution of the encoded video.
        :type max_width: int
        :param max_height: Optional. The maximum vertical resolution of the encoded video.
        :type max_height: int
        :param video_bit_rate: Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
        :type video_bit_rate: int
        :param subtitle_stream_index: Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
        :type subtitle_stream_index: int
        :param subtitle_method: Optional. Specify the subtitle delivery method.
        :type subtitle_method: SubtitleDeliveryMethod
        :param max_video_bit_depth: Optional.
        :type max_video_bit_depth: int
        :param video_codec: Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
        :type video_codec: str
        :param audio_stream_index: Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
        :type audio_stream_index: int
        :param video_stream_index: Optional. The index of the video stream to use. If omitted the first video stream will be used.
        :type video_stream_index: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_audio_by_id_stream_by_container_serialize(
            id=id,
            container=container,
            device_profile_id=device_profile_id,
            device_id=device_id,
            audio_codec=audio_codec,
            enable_auto_stream_copy=enable_auto_stream_copy,
            audio_sample_rate=audio_sample_rate,
            audio_bit_rate=audio_bit_rate,
            audio_channels=audio_channels,
            max_audio_channels=max_audio_channels,
            static=static,
            copy_timestamps=copy_timestamps,
            start_time_ticks=start_time_ticks,
            width=width,
            height=height,
            max_width=max_width,
            max_height=max_height,
            video_bit_rate=video_bit_rate,
            subtitle_stream_index=subtitle_stream_index,
            subtitle_method=subtitle_method,
            max_video_bit_depth=max_video_bit_depth,
            video_codec=video_codec,
            audio_stream_index=audio_stream_index,
            video_stream_index=video_stream_index,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '400': None,
            '401': None,
            '403': None,
            '404': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_audio_by_id_stream_by_container_serialize(
        self,
        id,
        container,
        device_profile_id,
        device_id,
        audio_codec,
        enable_auto_stream_copy,
        audio_sample_rate,
        audio_bit_rate,
        audio_channels,
        max_audio_channels,
        static,
        copy_timestamps,
        start_time_ticks,
        width,
        height,
        max_width,
        max_height,
        video_bit_rate,
        subtitle_stream_index,
        subtitle_method,
        max_video_bit_depth,
        video_codec,
        audio_stream_index,
        video_stream_index,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['Id'] = id
        if container is not None:
            _path_params['Container'] = container
        # process the query parameters
        if device_profile_id is not None:
            
            _query_params.append(('DeviceProfileId', device_profile_id))
            
        if device_id is not None:
            
            _query_params.append(('DeviceId', device_id))
            
        if audio_codec is not None:
            
            _query_params.append(('AudioCodec', audio_codec))
            
        if enable_auto_stream_copy is not None:
            
            _query_params.append(('EnableAutoStreamCopy', enable_auto_stream_copy))
            
        if audio_sample_rate is not None:
            
            _query_params.append(('AudioSampleRate', audio_sample_rate))
            
        if audio_bit_rate is not None:
            
            _query_params.append(('AudioBitRate', audio_bit_rate))
            
        if audio_channels is not None:
            
            _query_params.append(('AudioChannels', audio_channels))
            
        if max_audio_channels is not None:
            
            _query_params.append(('MaxAudioChannels', max_audio_channels))
            
        if static is not None:
            
            _query_params.append(('Static', static))
            
        if copy_timestamps is not None:
            
            _query_params.append(('CopyTimestamps', copy_timestamps))
            
        if start_time_ticks is not None:
            
            _query_params.append(('StartTimeTicks', start_time_ticks))
            
        if width is not None:
            
            _query_params.append(('Width', width))
            
        if height is not None:
            
            _query_params.append(('Height', height))
            
        if max_width is not None:
            
            _query_params.append(('MaxWidth', max_width))
            
        if max_height is not None:
            
            _query_params.append(('MaxHeight', max_height))
            
        if video_bit_rate is not None:
            
            _query_params.append(('VideoBitRate', video_bit_rate))
            
        if subtitle_stream_index is not None:
            
            _query_params.append(('SubtitleStreamIndex', subtitle_stream_index))
            
        if subtitle_method is not None:
            
            _query_params.append(('SubtitleMethod', subtitle_method.value))
            
        if max_video_bit_depth is not None:
            
            _query_params.append(('MaxVideoBitDepth', max_video_bit_depth))
            
        if video_codec is not None:
            
            _query_params.append(('VideoCodec', video_codec))
            
        if audio_stream_index is not None:
            
            _query_params.append(('AudioStreamIndex', audio_stream_index))
            
        if video_stream_index is not None:
            
            _query_params.append(('VideoStreamIndex', video_stream_index))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
            'apikeyauth', 
            'embyauth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/Audio/{Id}/stream.{Container}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def head_audio_by_id_by_streamfilename(
        self,
        stream_file_name: StrictStr,
        id: Annotated[StrictStr, Field(description="Item Id")],
        container: Annotated[StrictStr, Field(description="Container")],
        device_profile_id: Annotated[Optional[StrictStr], Field(description="Optional. The dlna device profile id to utilize.")] = None,
        device_id: Annotated[Optional[StrictStr], Field(description="The device id of the client requesting. Used to stop encoding processes when needed.")] = None,
        audio_codec: Annotated[Optional[StrictStr], Field(description="Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.")] = None,
        enable_auto_stream_copy: Annotated[Optional[StrictBool], Field(description="Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.")] = None,
        audio_sample_rate: Annotated[Optional[StrictInt], Field(description="Optional. Specify a specific audio sample rate, e.g. 44100")] = None,
        audio_bit_rate: Annotated[Optional[StrictInt], Field(description="Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.")] = None,
        audio_channels: Annotated[Optional[StrictInt], Field(description="Optional. Specify a specific number of audio channels to encode to, e.g. 2")] = None,
        max_audio_channels: Annotated[Optional[StrictInt], Field(description="Optional. Specify a maximum number of audio channels to encode to, e.g. 2")] = None,
        static: Annotated[Optional[StrictBool], Field(description="Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false")] = None,
        copy_timestamps: Annotated[Optional[StrictBool], Field(description="Whether or not to copy timestamps when transcoding with an offset. Defaults to false.")] = None,
        start_time_ticks: Annotated[Optional[StrictInt], Field(description="Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.")] = None,
        width: Annotated[Optional[StrictInt], Field(description="Optional. The fixed horizontal resolution of the encoded video.")] = None,
        height: Annotated[Optional[StrictInt], Field(description="Optional. The fixed vertical resolution of the encoded video.")] = None,
        max_width: Annotated[Optional[StrictInt], Field(description="Optional. The maximum horizontal resolution of the encoded video.")] = None,
        max_height: Annotated[Optional[StrictInt], Field(description="Optional. The maximum vertical resolution of the encoded video.")] = None,
        video_bit_rate: Annotated[Optional[StrictInt], Field(description="Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.")] = None,
        subtitle_stream_index: Annotated[Optional[StrictInt], Field(description="Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.")] = None,
        subtitle_method: Annotated[Optional[SubtitleDeliveryMethod], Field(description="Optional. Specify the subtitle delivery method.")] = None,
        max_video_bit_depth: Annotated[Optional[StrictInt], Field(description="Optional.")] = None,
        video_codec: Annotated[Optional[StrictStr], Field(description="Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.")] = None,
        audio_stream_index: Annotated[Optional[StrictInt], Field(description="Optional. The index of the audio stream to use. If omitted the first audio stream will be used.")] = None,
        video_stream_index: Annotated[Optional[StrictInt], Field(description="Optional. The index of the video stream to use. If omitted the first video stream will be used.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Gets an audio stream

        Requires authentication as user

        :param stream_file_name: (required)
        :type stream_file_name: str
        :param id: Item Id (required)
        :type id: str
        :param container: Container (required)
        :type container: str
        :param device_profile_id: Optional. The dlna device profile id to utilize.
        :type device_profile_id: str
        :param device_id: The device id of the client requesting. Used to stop encoding processes when needed.
        :type device_id: str
        :param audio_codec: Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
        :type audio_codec: str
        :param enable_auto_stream_copy: Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
        :type enable_auto_stream_copy: bool
        :param audio_sample_rate: Optional. Specify a specific audio sample rate, e.g. 44100
        :type audio_sample_rate: int
        :param audio_bit_rate: Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
        :type audio_bit_rate: int
        :param audio_channels: Optional. Specify a specific number of audio channels to encode to, e.g. 2
        :type audio_channels: int
        :param max_audio_channels: Optional. Specify a maximum number of audio channels to encode to, e.g. 2
        :type max_audio_channels: int
        :param static: Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
        :type static: bool
        :param copy_timestamps: Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
        :type copy_timestamps: bool
        :param start_time_ticks: Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
        :type start_time_ticks: int
        :param width: Optional. The fixed horizontal resolution of the encoded video.
        :type width: int
        :param height: Optional. The fixed vertical resolution of the encoded video.
        :type height: int
        :param max_width: Optional. The maximum horizontal resolution of the encoded video.
        :type max_width: int
        :param max_height: Optional. The maximum vertical resolution of the encoded video.
        :type max_height: int
        :param video_bit_rate: Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
        :type video_bit_rate: int
        :param subtitle_stream_index: Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
        :type subtitle_stream_index: int
        :param subtitle_method: Optional. Specify the subtitle delivery method.
        :type subtitle_method: SubtitleDeliveryMethod
        :param max_video_bit_depth: Optional.
        :type max_video_bit_depth: int
        :param video_codec: Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
        :type video_codec: str
        :param audio_stream_index: Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
        :type audio_stream_index: int
        :param video_stream_index: Optional. The index of the video stream to use. If omitted the first video stream will be used.
        :type video_stream_index: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._head_audio_by_id_by_streamfilename_serialize(
            stream_file_name=stream_file_name,
            id=id,
            container=container,
            device_profile_id=device_profile_id,
            device_id=device_id,
            audio_codec=audio_codec,
            enable_auto_stream_copy=enable_auto_stream_copy,
            audio_sample_rate=audio_sample_rate,
            audio_bit_rate=audio_bit_rate,
            audio_channels=audio_channels,
            max_audio_channels=max_audio_channels,
            static=static,
            copy_timestamps=copy_timestamps,
            start_time_ticks=start_time_ticks,
            width=width,
            height=height,
            max_width=max_width,
            max_height=max_height,
            video_bit_rate=video_bit_rate,
            subtitle_stream_index=subtitle_stream_index,
            subtitle_method=subtitle_method,
            max_video_bit_depth=max_video_bit_depth,
            video_codec=video_codec,
            audio_stream_index=audio_stream_index,
            video_stream_index=video_stream_index,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '400': None,
            '401': None,
            '403': None,
            '404': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def head_audio_by_id_by_streamfilename_with_http_info(
        self,
        stream_file_name: StrictStr,
        id: Annotated[StrictStr, Field(description="Item Id")],
        container: Annotated[StrictStr, Field(description="Container")],
        device_profile_id: Annotated[Optional[StrictStr], Field(description="Optional. The dlna device profile id to utilize.")] = None,
        device_id: Annotated[Optional[StrictStr], Field(description="The device id of the client requesting. Used to stop encoding processes when needed.")] = None,
        audio_codec: Annotated[Optional[StrictStr], Field(description="Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.")] = None,
        enable_auto_stream_copy: Annotated[Optional[StrictBool], Field(description="Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.")] = None,
        audio_sample_rate: Annotated[Optional[StrictInt], Field(description="Optional. Specify a specific audio sample rate, e.g. 44100")] = None,
        audio_bit_rate: Annotated[Optional[StrictInt], Field(description="Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.")] = None,
        audio_channels: Annotated[Optional[StrictInt], Field(description="Optional. Specify a specific number of audio channels to encode to, e.g. 2")] = None,
        max_audio_channels: Annotated[Optional[StrictInt], Field(description="Optional. Specify a maximum number of audio channels to encode to, e.g. 2")] = None,
        static: Annotated[Optional[StrictBool], Field(description="Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false")] = None,
        copy_timestamps: Annotated[Optional[StrictBool], Field(description="Whether or not to copy timestamps when transcoding with an offset. Defaults to false.")] = None,
        start_time_ticks: Annotated[Optional[StrictInt], Field(description="Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.")] = None,
        width: Annotated[Optional[StrictInt], Field(description="Optional. The fixed horizontal resolution of the encoded video.")] = None,
        height: Annotated[Optional[StrictInt], Field(description="Optional. The fixed vertical resolution of the encoded video.")] = None,
        max_width: Annotated[Optional[StrictInt], Field(description="Optional. The maximum horizontal resolution of the encoded video.")] = None,
        max_height: Annotated[Optional[StrictInt], Field(description="Optional. The maximum vertical resolution of the encoded video.")] = None,
        video_bit_rate: Annotated[Optional[StrictInt], Field(description="Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.")] = None,
        subtitle_stream_index: Annotated[Optional[StrictInt], Field(description="Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.")] = None,
        subtitle_method: Annotated[Optional[SubtitleDeliveryMethod], Field(description="Optional. Specify the subtitle delivery method.")] = None,
        max_video_bit_depth: Annotated[Optional[StrictInt], Field(description="Optional.")] = None,
        video_codec: Annotated[Optional[StrictStr], Field(description="Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.")] = None,
        audio_stream_index: Annotated[Optional[StrictInt], Field(description="Optional. The index of the audio stream to use. If omitted the first audio stream will be used.")] = None,
        video_stream_index: Annotated[Optional[StrictInt], Field(description="Optional. The index of the video stream to use. If omitted the first video stream will be used.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Gets an audio stream

        Requires authentication as user

        :param stream_file_name: (required)
        :type stream_file_name: str
        :param id: Item Id (required)
        :type id: str
        :param container: Container (required)
        :type container: str
        :param device_profile_id: Optional. The dlna device profile id to utilize.
        :type device_profile_id: str
        :param device_id: The device id of the client requesting. Used to stop encoding processes when needed.
        :type device_id: str
        :param audio_codec: Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
        :type audio_codec: str
        :param enable_auto_stream_copy: Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
        :type enable_auto_stream_copy: bool
        :param audio_sample_rate: Optional. Specify a specific audio sample rate, e.g. 44100
        :type audio_sample_rate: int
        :param audio_bit_rate: Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
        :type audio_bit_rate: int
        :param audio_channels: Optional. Specify a specific number of audio channels to encode to, e.g. 2
        :type audio_channels: int
        :param max_audio_channels: Optional. Specify a maximum number of audio channels to encode to, e.g. 2
        :type max_audio_channels: int
        :param static: Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
        :type static: bool
        :param copy_timestamps: Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
        :type copy_timestamps: bool
        :param start_time_ticks: Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
        :type start_time_ticks: int
        :param width: Optional. The fixed horizontal resolution of the encoded video.
        :type width: int
        :param height: Optional. The fixed vertical resolution of the encoded video.
        :type height: int
        :param max_width: Optional. The maximum horizontal resolution of the encoded video.
        :type max_width: int
        :param max_height: Optional. The maximum vertical resolution of the encoded video.
        :type max_height: int
        :param video_bit_rate: Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
        :type video_bit_rate: int
        :param subtitle_stream_index: Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
        :type subtitle_stream_index: int
        :param subtitle_method: Optional. Specify the subtitle delivery method.
        :type subtitle_method: SubtitleDeliveryMethod
        :param max_video_bit_depth: Optional.
        :type max_video_bit_depth: int
        :param video_codec: Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
        :type video_codec: str
        :param audio_stream_index: Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
        :type audio_stream_index: int
        :param video_stream_index: Optional. The index of the video stream to use. If omitted the first video stream will be used.
        :type video_stream_index: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._head_audio_by_id_by_streamfilename_serialize(
            stream_file_name=stream_file_name,
            id=id,
            container=container,
            device_profile_id=device_profile_id,
            device_id=device_id,
            audio_codec=audio_codec,
            enable_auto_stream_copy=enable_auto_stream_copy,
            audio_sample_rate=audio_sample_rate,
            audio_bit_rate=audio_bit_rate,
            audio_channels=audio_channels,
            max_audio_channels=max_audio_channels,
            static=static,
            copy_timestamps=copy_timestamps,
            start_time_ticks=start_time_ticks,
            width=width,
            height=height,
            max_width=max_width,
            max_height=max_height,
            video_bit_rate=video_bit_rate,
            subtitle_stream_index=subtitle_stream_index,
            subtitle_method=subtitle_method,
            max_video_bit_depth=max_video_bit_depth,
            video_codec=video_codec,
            audio_stream_index=audio_stream_index,
            video_stream_index=video_stream_index,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '400': None,
            '401': None,
            '403': None,
            '404': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def head_audio_by_id_by_streamfilename_without_preload_content(
        self,
        stream_file_name: StrictStr,
        id: Annotated[StrictStr, Field(description="Item Id")],
        container: Annotated[StrictStr, Field(description="Container")],
        device_profile_id: Annotated[Optional[StrictStr], Field(description="Optional. The dlna device profile id to utilize.")] = None,
        device_id: Annotated[Optional[StrictStr], Field(description="The device id of the client requesting. Used to stop encoding processes when needed.")] = None,
        audio_codec: Annotated[Optional[StrictStr], Field(description="Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.")] = None,
        enable_auto_stream_copy: Annotated[Optional[StrictBool], Field(description="Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.")] = None,
        audio_sample_rate: Annotated[Optional[StrictInt], Field(description="Optional. Specify a specific audio sample rate, e.g. 44100")] = None,
        audio_bit_rate: Annotated[Optional[StrictInt], Field(description="Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.")] = None,
        audio_channels: Annotated[Optional[StrictInt], Field(description="Optional. Specify a specific number of audio channels to encode to, e.g. 2")] = None,
        max_audio_channels: Annotated[Optional[StrictInt], Field(description="Optional. Specify a maximum number of audio channels to encode to, e.g. 2")] = None,
        static: Annotated[Optional[StrictBool], Field(description="Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false")] = None,
        copy_timestamps: Annotated[Optional[StrictBool], Field(description="Whether or not to copy timestamps when transcoding with an offset. Defaults to false.")] = None,
        start_time_ticks: Annotated[Optional[StrictInt], Field(description="Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.")] = None,
        width: Annotated[Optional[StrictInt], Field(description="Optional. The fixed horizontal resolution of the encoded video.")] = None,
        height: Annotated[Optional[StrictInt], Field(description="Optional. The fixed vertical resolution of the encoded video.")] = None,
        max_width: Annotated[Optional[StrictInt], Field(description="Optional. The maximum horizontal resolution of the encoded video.")] = None,
        max_height: Annotated[Optional[StrictInt], Field(description="Optional. The maximum vertical resolution of the encoded video.")] = None,
        video_bit_rate: Annotated[Optional[StrictInt], Field(description="Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.")] = None,
        subtitle_stream_index: Annotated[Optional[StrictInt], Field(description="Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.")] = None,
        subtitle_method: Annotated[Optional[SubtitleDeliveryMethod], Field(description="Optional. Specify the subtitle delivery method.")] = None,
        max_video_bit_depth: Annotated[Optional[StrictInt], Field(description="Optional.")] = None,
        video_codec: Annotated[Optional[StrictStr], Field(description="Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.")] = None,
        audio_stream_index: Annotated[Optional[StrictInt], Field(description="Optional. The index of the audio stream to use. If omitted the first audio stream will be used.")] = None,
        video_stream_index: Annotated[Optional[StrictInt], Field(description="Optional. The index of the video stream to use. If omitted the first video stream will be used.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Gets an audio stream

        Requires authentication as user

        :param stream_file_name: (required)
        :type stream_file_name: str
        :param id: Item Id (required)
        :type id: str
        :param container: Container (required)
        :type container: str
        :param device_profile_id: Optional. The dlna device profile id to utilize.
        :type device_profile_id: str
        :param device_id: The device id of the client requesting. Used to stop encoding processes when needed.
        :type device_id: str
        :param audio_codec: Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
        :type audio_codec: str
        :param enable_auto_stream_copy: Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
        :type enable_auto_stream_copy: bool
        :param audio_sample_rate: Optional. Specify a specific audio sample rate, e.g. 44100
        :type audio_sample_rate: int
        :param audio_bit_rate: Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
        :type audio_bit_rate: int
        :param audio_channels: Optional. Specify a specific number of audio channels to encode to, e.g. 2
        :type audio_channels: int
        :param max_audio_channels: Optional. Specify a maximum number of audio channels to encode to, e.g. 2
        :type max_audio_channels: int
        :param static: Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
        :type static: bool
        :param copy_timestamps: Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
        :type copy_timestamps: bool
        :param start_time_ticks: Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
        :type start_time_ticks: int
        :param width: Optional. The fixed horizontal resolution of the encoded video.
        :type width: int
        :param height: Optional. The fixed vertical resolution of the encoded video.
        :type height: int
        :param max_width: Optional. The maximum horizontal resolution of the encoded video.
        :type max_width: int
        :param max_height: Optional. The maximum vertical resolution of the encoded video.
        :type max_height: int
        :param video_bit_rate: Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
        :type video_bit_rate: int
        :param subtitle_stream_index: Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
        :type subtitle_stream_index: int
        :param subtitle_method: Optional. Specify the subtitle delivery method.
        :type subtitle_method: SubtitleDeliveryMethod
        :param max_video_bit_depth: Optional.
        :type max_video_bit_depth: int
        :param video_codec: Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
        :type video_codec: str
        :param audio_stream_index: Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
        :type audio_stream_index: int
        :param video_stream_index: Optional. The index of the video stream to use. If omitted the first video stream will be used.
        :type video_stream_index: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._head_audio_by_id_by_streamfilename_serialize(
            stream_file_name=stream_file_name,
            id=id,
            container=container,
            device_profile_id=device_profile_id,
            device_id=device_id,
            audio_codec=audio_codec,
            enable_auto_stream_copy=enable_auto_stream_copy,
            audio_sample_rate=audio_sample_rate,
            audio_bit_rate=audio_bit_rate,
            audio_channels=audio_channels,
            max_audio_channels=max_audio_channels,
            static=static,
            copy_timestamps=copy_timestamps,
            start_time_ticks=start_time_ticks,
            width=width,
            height=height,
            max_width=max_width,
            max_height=max_height,
            video_bit_rate=video_bit_rate,
            subtitle_stream_index=subtitle_stream_index,
            subtitle_method=subtitle_method,
            max_video_bit_depth=max_video_bit_depth,
            video_codec=video_codec,
            audio_stream_index=audio_stream_index,
            video_stream_index=video_stream_index,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '400': None,
            '401': None,
            '403': None,
            '404': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _head_audio_by_id_by_streamfilename_serialize(
        self,
        stream_file_name,
        id,
        container,
        device_profile_id,
        device_id,
        audio_codec,
        enable_auto_stream_copy,
        audio_sample_rate,
        audio_bit_rate,
        audio_channels,
        max_audio_channels,
        static,
        copy_timestamps,
        start_time_ticks,
        width,
        height,
        max_width,
        max_height,
        video_bit_rate,
        subtitle_stream_index,
        subtitle_method,
        max_video_bit_depth,
        video_codec,
        audio_stream_index,
        video_stream_index,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if stream_file_name is not None:
            _path_params['StreamFileName'] = stream_file_name
        if id is not None:
            _path_params['Id'] = id
        # process the query parameters
        if device_profile_id is not None:
            
            _query_params.append(('DeviceProfileId', device_profile_id))
            
        if device_id is not None:
            
            _query_params.append(('DeviceId', device_id))
            
        if container is not None:
            
            _query_params.append(('Container', container))
            
        if audio_codec is not None:
            
            _query_params.append(('AudioCodec', audio_codec))
            
        if enable_auto_stream_copy is not None:
            
            _query_params.append(('EnableAutoStreamCopy', enable_auto_stream_copy))
            
        if audio_sample_rate is not None:
            
            _query_params.append(('AudioSampleRate', audio_sample_rate))
            
        if audio_bit_rate is not None:
            
            _query_params.append(('AudioBitRate', audio_bit_rate))
            
        if audio_channels is not None:
            
            _query_params.append(('AudioChannels', audio_channels))
            
        if max_audio_channels is not None:
            
            _query_params.append(('MaxAudioChannels', max_audio_channels))
            
        if static is not None:
            
            _query_params.append(('Static', static))
            
        if copy_timestamps is not None:
            
            _query_params.append(('CopyTimestamps', copy_timestamps))
            
        if start_time_ticks is not None:
            
            _query_params.append(('StartTimeTicks', start_time_ticks))
            
        if width is not None:
            
            _query_params.append(('Width', width))
            
        if height is not None:
            
            _query_params.append(('Height', height))
            
        if max_width is not None:
            
            _query_params.append(('MaxWidth', max_width))
            
        if max_height is not None:
            
            _query_params.append(('MaxHeight', max_height))
            
        if video_bit_rate is not None:
            
            _query_params.append(('VideoBitRate', video_bit_rate))
            
        if subtitle_stream_index is not None:
            
            _query_params.append(('SubtitleStreamIndex', subtitle_stream_index))
            
        if subtitle_method is not None:
            
            _query_params.append(('SubtitleMethod', subtitle_method.value))
            
        if max_video_bit_depth is not None:
            
            _query_params.append(('MaxVideoBitDepth', max_video_bit_depth))
            
        if video_codec is not None:
            
            _query_params.append(('VideoCodec', video_codec))
            
        if audio_stream_index is not None:
            
            _query_params.append(('AudioStreamIndex', audio_stream_index))
            
        if video_stream_index is not None:
            
            _query_params.append(('VideoStreamIndex', video_stream_index))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
            'apikeyauth', 
            'embyauth'
        ]

        return self.api_client.param_serialize(
            method='HEAD',
            resource_path='/Audio/{Id}/{StreamFileName}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def head_audio_by_id_stream(
        self,
        id: Annotated[StrictStr, Field(description="Item Id")],
        container: Annotated[StrictStr, Field(description="Container")],
        device_profile_id: Annotated[Optional[StrictStr], Field(description="Optional. The dlna device profile id to utilize.")] = None,
        device_id: Annotated[Optional[StrictStr], Field(description="The device id of the client requesting. Used to stop encoding processes when needed.")] = None,
        audio_codec: Annotated[Optional[StrictStr], Field(description="Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.")] = None,
        enable_auto_stream_copy: Annotated[Optional[StrictBool], Field(description="Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.")] = None,
        audio_sample_rate: Annotated[Optional[StrictInt], Field(description="Optional. Specify a specific audio sample rate, e.g. 44100")] = None,
        audio_bit_rate: Annotated[Optional[StrictInt], Field(description="Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.")] = None,
        audio_channels: Annotated[Optional[StrictInt], Field(description="Optional. Specify a specific number of audio channels to encode to, e.g. 2")] = None,
        max_audio_channels: Annotated[Optional[StrictInt], Field(description="Optional. Specify a maximum number of audio channels to encode to, e.g. 2")] = None,
        static: Annotated[Optional[StrictBool], Field(description="Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false")] = None,
        copy_timestamps: Annotated[Optional[StrictBool], Field(description="Whether or not to copy timestamps when transcoding with an offset. Defaults to false.")] = None,
        start_time_ticks: Annotated[Optional[StrictInt], Field(description="Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.")] = None,
        width: Annotated[Optional[StrictInt], Field(description="Optional. The fixed horizontal resolution of the encoded video.")] = None,
        height: Annotated[Optional[StrictInt], Field(description="Optional. The fixed vertical resolution of the encoded video.")] = None,
        max_width: Annotated[Optional[StrictInt], Field(description="Optional. The maximum horizontal resolution of the encoded video.")] = None,
        max_height: Annotated[Optional[StrictInt], Field(description="Optional. The maximum vertical resolution of the encoded video.")] = None,
        video_bit_rate: Annotated[Optional[StrictInt], Field(description="Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.")] = None,
        subtitle_stream_index: Annotated[Optional[StrictInt], Field(description="Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.")] = None,
        subtitle_method: Annotated[Optional[SubtitleDeliveryMethod], Field(description="Optional. Specify the subtitle delivery method.")] = None,
        max_video_bit_depth: Annotated[Optional[StrictInt], Field(description="Optional.")] = None,
        video_codec: Annotated[Optional[StrictStr], Field(description="Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.")] = None,
        audio_stream_index: Annotated[Optional[StrictInt], Field(description="Optional. The index of the audio stream to use. If omitted the first audio stream will be used.")] = None,
        video_stream_index: Annotated[Optional[StrictInt], Field(description="Optional. The index of the video stream to use. If omitted the first video stream will be used.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Gets an audio stream

        Requires authentication as user

        :param id: Item Id (required)
        :type id: str
        :param container: Container (required)
        :type container: str
        :param device_profile_id: Optional. The dlna device profile id to utilize.
        :type device_profile_id: str
        :param device_id: The device id of the client requesting. Used to stop encoding processes when needed.
        :type device_id: str
        :param audio_codec: Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
        :type audio_codec: str
        :param enable_auto_stream_copy: Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
        :type enable_auto_stream_copy: bool
        :param audio_sample_rate: Optional. Specify a specific audio sample rate, e.g. 44100
        :type audio_sample_rate: int
        :param audio_bit_rate: Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
        :type audio_bit_rate: int
        :param audio_channels: Optional. Specify a specific number of audio channels to encode to, e.g. 2
        :type audio_channels: int
        :param max_audio_channels: Optional. Specify a maximum number of audio channels to encode to, e.g. 2
        :type max_audio_channels: int
        :param static: Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
        :type static: bool
        :param copy_timestamps: Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
        :type copy_timestamps: bool
        :param start_time_ticks: Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
        :type start_time_ticks: int
        :param width: Optional. The fixed horizontal resolution of the encoded video.
        :type width: int
        :param height: Optional. The fixed vertical resolution of the encoded video.
        :type height: int
        :param max_width: Optional. The maximum horizontal resolution of the encoded video.
        :type max_width: int
        :param max_height: Optional. The maximum vertical resolution of the encoded video.
        :type max_height: int
        :param video_bit_rate: Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
        :type video_bit_rate: int
        :param subtitle_stream_index: Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
        :type subtitle_stream_index: int
        :param subtitle_method: Optional. Specify the subtitle delivery method.
        :type subtitle_method: SubtitleDeliveryMethod
        :param max_video_bit_depth: Optional.
        :type max_video_bit_depth: int
        :param video_codec: Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
        :type video_codec: str
        :param audio_stream_index: Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
        :type audio_stream_index: int
        :param video_stream_index: Optional. The index of the video stream to use. If omitted the first video stream will be used.
        :type video_stream_index: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._head_audio_by_id_stream_serialize(
            id=id,
            container=container,
            device_profile_id=device_profile_id,
            device_id=device_id,
            audio_codec=audio_codec,
            enable_auto_stream_copy=enable_auto_stream_copy,
            audio_sample_rate=audio_sample_rate,
            audio_bit_rate=audio_bit_rate,
            audio_channels=audio_channels,
            max_audio_channels=max_audio_channels,
            static=static,
            copy_timestamps=copy_timestamps,
            start_time_ticks=start_time_ticks,
            width=width,
            height=height,
            max_width=max_width,
            max_height=max_height,
            video_bit_rate=video_bit_rate,
            subtitle_stream_index=subtitle_stream_index,
            subtitle_method=subtitle_method,
            max_video_bit_depth=max_video_bit_depth,
            video_codec=video_codec,
            audio_stream_index=audio_stream_index,
            video_stream_index=video_stream_index,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '400': None,
            '401': None,
            '403': None,
            '404': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def head_audio_by_id_stream_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="Item Id")],
        container: Annotated[StrictStr, Field(description="Container")],
        device_profile_id: Annotated[Optional[StrictStr], Field(description="Optional. The dlna device profile id to utilize.")] = None,
        device_id: Annotated[Optional[StrictStr], Field(description="The device id of the client requesting. Used to stop encoding processes when needed.")] = None,
        audio_codec: Annotated[Optional[StrictStr], Field(description="Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.")] = None,
        enable_auto_stream_copy: Annotated[Optional[StrictBool], Field(description="Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.")] = None,
        audio_sample_rate: Annotated[Optional[StrictInt], Field(description="Optional. Specify a specific audio sample rate, e.g. 44100")] = None,
        audio_bit_rate: Annotated[Optional[StrictInt], Field(description="Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.")] = None,
        audio_channels: Annotated[Optional[StrictInt], Field(description="Optional. Specify a specific number of audio channels to encode to, e.g. 2")] = None,
        max_audio_channels: Annotated[Optional[StrictInt], Field(description="Optional. Specify a maximum number of audio channels to encode to, e.g. 2")] = None,
        static: Annotated[Optional[StrictBool], Field(description="Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false")] = None,
        copy_timestamps: Annotated[Optional[StrictBool], Field(description="Whether or not to copy timestamps when transcoding with an offset. Defaults to false.")] = None,
        start_time_ticks: Annotated[Optional[StrictInt], Field(description="Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.")] = None,
        width: Annotated[Optional[StrictInt], Field(description="Optional. The fixed horizontal resolution of the encoded video.")] = None,
        height: Annotated[Optional[StrictInt], Field(description="Optional. The fixed vertical resolution of the encoded video.")] = None,
        max_width: Annotated[Optional[StrictInt], Field(description="Optional. The maximum horizontal resolution of the encoded video.")] = None,
        max_height: Annotated[Optional[StrictInt], Field(description="Optional. The maximum vertical resolution of the encoded video.")] = None,
        video_bit_rate: Annotated[Optional[StrictInt], Field(description="Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.")] = None,
        subtitle_stream_index: Annotated[Optional[StrictInt], Field(description="Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.")] = None,
        subtitle_method: Annotated[Optional[SubtitleDeliveryMethod], Field(description="Optional. Specify the subtitle delivery method.")] = None,
        max_video_bit_depth: Annotated[Optional[StrictInt], Field(description="Optional.")] = None,
        video_codec: Annotated[Optional[StrictStr], Field(description="Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.")] = None,
        audio_stream_index: Annotated[Optional[StrictInt], Field(description="Optional. The index of the audio stream to use. If omitted the first audio stream will be used.")] = None,
        video_stream_index: Annotated[Optional[StrictInt], Field(description="Optional. The index of the video stream to use. If omitted the first video stream will be used.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Gets an audio stream

        Requires authentication as user

        :param id: Item Id (required)
        :type id: str
        :param container: Container (required)
        :type container: str
        :param device_profile_id: Optional. The dlna device profile id to utilize.
        :type device_profile_id: str
        :param device_id: The device id of the client requesting. Used to stop encoding processes when needed.
        :type device_id: str
        :param audio_codec: Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
        :type audio_codec: str
        :param enable_auto_stream_copy: Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
        :type enable_auto_stream_copy: bool
        :param audio_sample_rate: Optional. Specify a specific audio sample rate, e.g. 44100
        :type audio_sample_rate: int
        :param audio_bit_rate: Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
        :type audio_bit_rate: int
        :param audio_channels: Optional. Specify a specific number of audio channels to encode to, e.g. 2
        :type audio_channels: int
        :param max_audio_channels: Optional. Specify a maximum number of audio channels to encode to, e.g. 2
        :type max_audio_channels: int
        :param static: Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
        :type static: bool
        :param copy_timestamps: Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
        :type copy_timestamps: bool
        :param start_time_ticks: Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
        :type start_time_ticks: int
        :param width: Optional. The fixed horizontal resolution of the encoded video.
        :type width: int
        :param height: Optional. The fixed vertical resolution of the encoded video.
        :type height: int
        :param max_width: Optional. The maximum horizontal resolution of the encoded video.
        :type max_width: int
        :param max_height: Optional. The maximum vertical resolution of the encoded video.
        :type max_height: int
        :param video_bit_rate: Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
        :type video_bit_rate: int
        :param subtitle_stream_index: Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
        :type subtitle_stream_index: int
        :param subtitle_method: Optional. Specify the subtitle delivery method.
        :type subtitle_method: SubtitleDeliveryMethod
        :param max_video_bit_depth: Optional.
        :type max_video_bit_depth: int
        :param video_codec: Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
        :type video_codec: str
        :param audio_stream_index: Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
        :type audio_stream_index: int
        :param video_stream_index: Optional. The index of the video stream to use. If omitted the first video stream will be used.
        :type video_stream_index: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._head_audio_by_id_stream_serialize(
            id=id,
            container=container,
            device_profile_id=device_profile_id,
            device_id=device_id,
            audio_codec=audio_codec,
            enable_auto_stream_copy=enable_auto_stream_copy,
            audio_sample_rate=audio_sample_rate,
            audio_bit_rate=audio_bit_rate,
            audio_channels=audio_channels,
            max_audio_channels=max_audio_channels,
            static=static,
            copy_timestamps=copy_timestamps,
            start_time_ticks=start_time_ticks,
            width=width,
            height=height,
            max_width=max_width,
            max_height=max_height,
            video_bit_rate=video_bit_rate,
            subtitle_stream_index=subtitle_stream_index,
            subtitle_method=subtitle_method,
            max_video_bit_depth=max_video_bit_depth,
            video_codec=video_codec,
            audio_stream_index=audio_stream_index,
            video_stream_index=video_stream_index,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '400': None,
            '401': None,
            '403': None,
            '404': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def head_audio_by_id_stream_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="Item Id")],
        container: Annotated[StrictStr, Field(description="Container")],
        device_profile_id: Annotated[Optional[StrictStr], Field(description="Optional. The dlna device profile id to utilize.")] = None,
        device_id: Annotated[Optional[StrictStr], Field(description="The device id of the client requesting. Used to stop encoding processes when needed.")] = None,
        audio_codec: Annotated[Optional[StrictStr], Field(description="Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.")] = None,
        enable_auto_stream_copy: Annotated[Optional[StrictBool], Field(description="Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.")] = None,
        audio_sample_rate: Annotated[Optional[StrictInt], Field(description="Optional. Specify a specific audio sample rate, e.g. 44100")] = None,
        audio_bit_rate: Annotated[Optional[StrictInt], Field(description="Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.")] = None,
        audio_channels: Annotated[Optional[StrictInt], Field(description="Optional. Specify a specific number of audio channels to encode to, e.g. 2")] = None,
        max_audio_channels: Annotated[Optional[StrictInt], Field(description="Optional. Specify a maximum number of audio channels to encode to, e.g. 2")] = None,
        static: Annotated[Optional[StrictBool], Field(description="Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false")] = None,
        copy_timestamps: Annotated[Optional[StrictBool], Field(description="Whether or not to copy timestamps when transcoding with an offset. Defaults to false.")] = None,
        start_time_ticks: Annotated[Optional[StrictInt], Field(description="Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.")] = None,
        width: Annotated[Optional[StrictInt], Field(description="Optional. The fixed horizontal resolution of the encoded video.")] = None,
        height: Annotated[Optional[StrictInt], Field(description="Optional. The fixed vertical resolution of the encoded video.")] = None,
        max_width: Annotated[Optional[StrictInt], Field(description="Optional. The maximum horizontal resolution of the encoded video.")] = None,
        max_height: Annotated[Optional[StrictInt], Field(description="Optional. The maximum vertical resolution of the encoded video.")] = None,
        video_bit_rate: Annotated[Optional[StrictInt], Field(description="Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.")] = None,
        subtitle_stream_index: Annotated[Optional[StrictInt], Field(description="Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.")] = None,
        subtitle_method: Annotated[Optional[SubtitleDeliveryMethod], Field(description="Optional. Specify the subtitle delivery method.")] = None,
        max_video_bit_depth: Annotated[Optional[StrictInt], Field(description="Optional.")] = None,
        video_codec: Annotated[Optional[StrictStr], Field(description="Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.")] = None,
        audio_stream_index: Annotated[Optional[StrictInt], Field(description="Optional. The index of the audio stream to use. If omitted the first audio stream will be used.")] = None,
        video_stream_index: Annotated[Optional[StrictInt], Field(description="Optional. The index of the video stream to use. If omitted the first video stream will be used.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Gets an audio stream

        Requires authentication as user

        :param id: Item Id (required)
        :type id: str
        :param container: Container (required)
        :type container: str
        :param device_profile_id: Optional. The dlna device profile id to utilize.
        :type device_profile_id: str
        :param device_id: The device id of the client requesting. Used to stop encoding processes when needed.
        :type device_id: str
        :param audio_codec: Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
        :type audio_codec: str
        :param enable_auto_stream_copy: Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
        :type enable_auto_stream_copy: bool
        :param audio_sample_rate: Optional. Specify a specific audio sample rate, e.g. 44100
        :type audio_sample_rate: int
        :param audio_bit_rate: Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
        :type audio_bit_rate: int
        :param audio_channels: Optional. Specify a specific number of audio channels to encode to, e.g. 2
        :type audio_channels: int
        :param max_audio_channels: Optional. Specify a maximum number of audio channels to encode to, e.g. 2
        :type max_audio_channels: int
        :param static: Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
        :type static: bool
        :param copy_timestamps: Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
        :type copy_timestamps: bool
        :param start_time_ticks: Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
        :type start_time_ticks: int
        :param width: Optional. The fixed horizontal resolution of the encoded video.
        :type width: int
        :param height: Optional. The fixed vertical resolution of the encoded video.
        :type height: int
        :param max_width: Optional. The maximum horizontal resolution of the encoded video.
        :type max_width: int
        :param max_height: Optional. The maximum vertical resolution of the encoded video.
        :type max_height: int
        :param video_bit_rate: Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
        :type video_bit_rate: int
        :param subtitle_stream_index: Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
        :type subtitle_stream_index: int
        :param subtitle_method: Optional. Specify the subtitle delivery method.
        :type subtitle_method: SubtitleDeliveryMethod
        :param max_video_bit_depth: Optional.
        :type max_video_bit_depth: int
        :param video_codec: Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
        :type video_codec: str
        :param audio_stream_index: Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
        :type audio_stream_index: int
        :param video_stream_index: Optional. The index of the video stream to use. If omitted the first video stream will be used.
        :type video_stream_index: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._head_audio_by_id_stream_serialize(
            id=id,
            container=container,
            device_profile_id=device_profile_id,
            device_id=device_id,
            audio_codec=audio_codec,
            enable_auto_stream_copy=enable_auto_stream_copy,
            audio_sample_rate=audio_sample_rate,
            audio_bit_rate=audio_bit_rate,
            audio_channels=audio_channels,
            max_audio_channels=max_audio_channels,
            static=static,
            copy_timestamps=copy_timestamps,
            start_time_ticks=start_time_ticks,
            width=width,
            height=height,
            max_width=max_width,
            max_height=max_height,
            video_bit_rate=video_bit_rate,
            subtitle_stream_index=subtitle_stream_index,
            subtitle_method=subtitle_method,
            max_video_bit_depth=max_video_bit_depth,
            video_codec=video_codec,
            audio_stream_index=audio_stream_index,
            video_stream_index=video_stream_index,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '400': None,
            '401': None,
            '403': None,
            '404': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _head_audio_by_id_stream_serialize(
        self,
        id,
        container,
        device_profile_id,
        device_id,
        audio_codec,
        enable_auto_stream_copy,
        audio_sample_rate,
        audio_bit_rate,
        audio_channels,
        max_audio_channels,
        static,
        copy_timestamps,
        start_time_ticks,
        width,
        height,
        max_width,
        max_height,
        video_bit_rate,
        subtitle_stream_index,
        subtitle_method,
        max_video_bit_depth,
        video_codec,
        audio_stream_index,
        video_stream_index,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['Id'] = id
        # process the query parameters
        if device_profile_id is not None:
            
            _query_params.append(('DeviceProfileId', device_profile_id))
            
        if device_id is not None:
            
            _query_params.append(('DeviceId', device_id))
            
        if container is not None:
            
            _query_params.append(('Container', container))
            
        if audio_codec is not None:
            
            _query_params.append(('AudioCodec', audio_codec))
            
        if enable_auto_stream_copy is not None:
            
            _query_params.append(('EnableAutoStreamCopy', enable_auto_stream_copy))
            
        if audio_sample_rate is not None:
            
            _query_params.append(('AudioSampleRate', audio_sample_rate))
            
        if audio_bit_rate is not None:
            
            _query_params.append(('AudioBitRate', audio_bit_rate))
            
        if audio_channels is not None:
            
            _query_params.append(('AudioChannels', audio_channels))
            
        if max_audio_channels is not None:
            
            _query_params.append(('MaxAudioChannels', max_audio_channels))
            
        if static is not None:
            
            _query_params.append(('Static', static))
            
        if copy_timestamps is not None:
            
            _query_params.append(('CopyTimestamps', copy_timestamps))
            
        if start_time_ticks is not None:
            
            _query_params.append(('StartTimeTicks', start_time_ticks))
            
        if width is not None:
            
            _query_params.append(('Width', width))
            
        if height is not None:
            
            _query_params.append(('Height', height))
            
        if max_width is not None:
            
            _query_params.append(('MaxWidth', max_width))
            
        if max_height is not None:
            
            _query_params.append(('MaxHeight', max_height))
            
        if video_bit_rate is not None:
            
            _query_params.append(('VideoBitRate', video_bit_rate))
            
        if subtitle_stream_index is not None:
            
            _query_params.append(('SubtitleStreamIndex', subtitle_stream_index))
            
        if subtitle_method is not None:
            
            _query_params.append(('SubtitleMethod', subtitle_method.value))
            
        if max_video_bit_depth is not None:
            
            _query_params.append(('MaxVideoBitDepth', max_video_bit_depth))
            
        if video_codec is not None:
            
            _query_params.append(('VideoCodec', video_codec))
            
        if audio_stream_index is not None:
            
            _query_params.append(('AudioStreamIndex', audio_stream_index))
            
        if video_stream_index is not None:
            
            _query_params.append(('VideoStreamIndex', video_stream_index))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
            'apikeyauth', 
            'embyauth'
        ]

        return self.api_client.param_serialize(
            method='HEAD',
            resource_path='/Audio/{Id}/stream',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def head_audio_by_id_stream_by_container(
        self,
        id: Annotated[StrictStr, Field(description="Item Id")],
        container: Annotated[StrictStr, Field(description="Container")],
        device_profile_id: Annotated[Optional[StrictStr], Field(description="Optional. The dlna device profile id to utilize.")] = None,
        device_id: Annotated[Optional[StrictStr], Field(description="The device id of the client requesting. Used to stop encoding processes when needed.")] = None,
        audio_codec: Annotated[Optional[StrictStr], Field(description="Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.")] = None,
        enable_auto_stream_copy: Annotated[Optional[StrictBool], Field(description="Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.")] = None,
        audio_sample_rate: Annotated[Optional[StrictInt], Field(description="Optional. Specify a specific audio sample rate, e.g. 44100")] = None,
        audio_bit_rate: Annotated[Optional[StrictInt], Field(description="Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.")] = None,
        audio_channels: Annotated[Optional[StrictInt], Field(description="Optional. Specify a specific number of audio channels to encode to, e.g. 2")] = None,
        max_audio_channels: Annotated[Optional[StrictInt], Field(description="Optional. Specify a maximum number of audio channels to encode to, e.g. 2")] = None,
        static: Annotated[Optional[StrictBool], Field(description="Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false")] = None,
        copy_timestamps: Annotated[Optional[StrictBool], Field(description="Whether or not to copy timestamps when transcoding with an offset. Defaults to false.")] = None,
        start_time_ticks: Annotated[Optional[StrictInt], Field(description="Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.")] = None,
        width: Annotated[Optional[StrictInt], Field(description="Optional. The fixed horizontal resolution of the encoded video.")] = None,
        height: Annotated[Optional[StrictInt], Field(description="Optional. The fixed vertical resolution of the encoded video.")] = None,
        max_width: Annotated[Optional[StrictInt], Field(description="Optional. The maximum horizontal resolution of the encoded video.")] = None,
        max_height: Annotated[Optional[StrictInt], Field(description="Optional. The maximum vertical resolution of the encoded video.")] = None,
        video_bit_rate: Annotated[Optional[StrictInt], Field(description="Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.")] = None,
        subtitle_stream_index: Annotated[Optional[StrictInt], Field(description="Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.")] = None,
        subtitle_method: Annotated[Optional[SubtitleDeliveryMethod], Field(description="Optional. Specify the subtitle delivery method.")] = None,
        max_video_bit_depth: Annotated[Optional[StrictInt], Field(description="Optional.")] = None,
        video_codec: Annotated[Optional[StrictStr], Field(description="Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.")] = None,
        audio_stream_index: Annotated[Optional[StrictInt], Field(description="Optional. The index of the audio stream to use. If omitted the first audio stream will be used.")] = None,
        video_stream_index: Annotated[Optional[StrictInt], Field(description="Optional. The index of the video stream to use. If omitted the first video stream will be used.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Gets an audio stream

        Requires authentication as user

        :param id: Item Id (required)
        :type id: str
        :param container: Container (required)
        :type container: str
        :param device_profile_id: Optional. The dlna device profile id to utilize.
        :type device_profile_id: str
        :param device_id: The device id of the client requesting. Used to stop encoding processes when needed.
        :type device_id: str
        :param audio_codec: Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
        :type audio_codec: str
        :param enable_auto_stream_copy: Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
        :type enable_auto_stream_copy: bool
        :param audio_sample_rate: Optional. Specify a specific audio sample rate, e.g. 44100
        :type audio_sample_rate: int
        :param audio_bit_rate: Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
        :type audio_bit_rate: int
        :param audio_channels: Optional. Specify a specific number of audio channels to encode to, e.g. 2
        :type audio_channels: int
        :param max_audio_channels: Optional. Specify a maximum number of audio channels to encode to, e.g. 2
        :type max_audio_channels: int
        :param static: Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
        :type static: bool
        :param copy_timestamps: Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
        :type copy_timestamps: bool
        :param start_time_ticks: Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
        :type start_time_ticks: int
        :param width: Optional. The fixed horizontal resolution of the encoded video.
        :type width: int
        :param height: Optional. The fixed vertical resolution of the encoded video.
        :type height: int
        :param max_width: Optional. The maximum horizontal resolution of the encoded video.
        :type max_width: int
        :param max_height: Optional. The maximum vertical resolution of the encoded video.
        :type max_height: int
        :param video_bit_rate: Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
        :type video_bit_rate: int
        :param subtitle_stream_index: Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
        :type subtitle_stream_index: int
        :param subtitle_method: Optional. Specify the subtitle delivery method.
        :type subtitle_method: SubtitleDeliveryMethod
        :param max_video_bit_depth: Optional.
        :type max_video_bit_depth: int
        :param video_codec: Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
        :type video_codec: str
        :param audio_stream_index: Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
        :type audio_stream_index: int
        :param video_stream_index: Optional. The index of the video stream to use. If omitted the first video stream will be used.
        :type video_stream_index: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._head_audio_by_id_stream_by_container_serialize(
            id=id,
            container=container,
            device_profile_id=device_profile_id,
            device_id=device_id,
            audio_codec=audio_codec,
            enable_auto_stream_copy=enable_auto_stream_copy,
            audio_sample_rate=audio_sample_rate,
            audio_bit_rate=audio_bit_rate,
            audio_channels=audio_channels,
            max_audio_channels=max_audio_channels,
            static=static,
            copy_timestamps=copy_timestamps,
            start_time_ticks=start_time_ticks,
            width=width,
            height=height,
            max_width=max_width,
            max_height=max_height,
            video_bit_rate=video_bit_rate,
            subtitle_stream_index=subtitle_stream_index,
            subtitle_method=subtitle_method,
            max_video_bit_depth=max_video_bit_depth,
            video_codec=video_codec,
            audio_stream_index=audio_stream_index,
            video_stream_index=video_stream_index,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '400': None,
            '401': None,
            '403': None,
            '404': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def head_audio_by_id_stream_by_container_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="Item Id")],
        container: Annotated[StrictStr, Field(description="Container")],
        device_profile_id: Annotated[Optional[StrictStr], Field(description="Optional. The dlna device profile id to utilize.")] = None,
        device_id: Annotated[Optional[StrictStr], Field(description="The device id of the client requesting. Used to stop encoding processes when needed.")] = None,
        audio_codec: Annotated[Optional[StrictStr], Field(description="Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.")] = None,
        enable_auto_stream_copy: Annotated[Optional[StrictBool], Field(description="Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.")] = None,
        audio_sample_rate: Annotated[Optional[StrictInt], Field(description="Optional. Specify a specific audio sample rate, e.g. 44100")] = None,
        audio_bit_rate: Annotated[Optional[StrictInt], Field(description="Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.")] = None,
        audio_channels: Annotated[Optional[StrictInt], Field(description="Optional. Specify a specific number of audio channels to encode to, e.g. 2")] = None,
        max_audio_channels: Annotated[Optional[StrictInt], Field(description="Optional. Specify a maximum number of audio channels to encode to, e.g. 2")] = None,
        static: Annotated[Optional[StrictBool], Field(description="Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false")] = None,
        copy_timestamps: Annotated[Optional[StrictBool], Field(description="Whether or not to copy timestamps when transcoding with an offset. Defaults to false.")] = None,
        start_time_ticks: Annotated[Optional[StrictInt], Field(description="Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.")] = None,
        width: Annotated[Optional[StrictInt], Field(description="Optional. The fixed horizontal resolution of the encoded video.")] = None,
        height: Annotated[Optional[StrictInt], Field(description="Optional. The fixed vertical resolution of the encoded video.")] = None,
        max_width: Annotated[Optional[StrictInt], Field(description="Optional. The maximum horizontal resolution of the encoded video.")] = None,
        max_height: Annotated[Optional[StrictInt], Field(description="Optional. The maximum vertical resolution of the encoded video.")] = None,
        video_bit_rate: Annotated[Optional[StrictInt], Field(description="Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.")] = None,
        subtitle_stream_index: Annotated[Optional[StrictInt], Field(description="Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.")] = None,
        subtitle_method: Annotated[Optional[SubtitleDeliveryMethod], Field(description="Optional. Specify the subtitle delivery method.")] = None,
        max_video_bit_depth: Annotated[Optional[StrictInt], Field(description="Optional.")] = None,
        video_codec: Annotated[Optional[StrictStr], Field(description="Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.")] = None,
        audio_stream_index: Annotated[Optional[StrictInt], Field(description="Optional. The index of the audio stream to use. If omitted the first audio stream will be used.")] = None,
        video_stream_index: Annotated[Optional[StrictInt], Field(description="Optional. The index of the video stream to use. If omitted the first video stream will be used.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Gets an audio stream

        Requires authentication as user

        :param id: Item Id (required)
        :type id: str
        :param container: Container (required)
        :type container: str
        :param device_profile_id: Optional. The dlna device profile id to utilize.
        :type device_profile_id: str
        :param device_id: The device id of the client requesting. Used to stop encoding processes when needed.
        :type device_id: str
        :param audio_codec: Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
        :type audio_codec: str
        :param enable_auto_stream_copy: Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
        :type enable_auto_stream_copy: bool
        :param audio_sample_rate: Optional. Specify a specific audio sample rate, e.g. 44100
        :type audio_sample_rate: int
        :param audio_bit_rate: Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
        :type audio_bit_rate: int
        :param audio_channels: Optional. Specify a specific number of audio channels to encode to, e.g. 2
        :type audio_channels: int
        :param max_audio_channels: Optional. Specify a maximum number of audio channels to encode to, e.g. 2
        :type max_audio_channels: int
        :param static: Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
        :type static: bool
        :param copy_timestamps: Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
        :type copy_timestamps: bool
        :param start_time_ticks: Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
        :type start_time_ticks: int
        :param width: Optional. The fixed horizontal resolution of the encoded video.
        :type width: int
        :param height: Optional. The fixed vertical resolution of the encoded video.
        :type height: int
        :param max_width: Optional. The maximum horizontal resolution of the encoded video.
        :type max_width: int
        :param max_height: Optional. The maximum vertical resolution of the encoded video.
        :type max_height: int
        :param video_bit_rate: Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
        :type video_bit_rate: int
        :param subtitle_stream_index: Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
        :type subtitle_stream_index: int
        :param subtitle_method: Optional. Specify the subtitle delivery method.
        :type subtitle_method: SubtitleDeliveryMethod
        :param max_video_bit_depth: Optional.
        :type max_video_bit_depth: int
        :param video_codec: Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
        :type video_codec: str
        :param audio_stream_index: Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
        :type audio_stream_index: int
        :param video_stream_index: Optional. The index of the video stream to use. If omitted the first video stream will be used.
        :type video_stream_index: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._head_audio_by_id_stream_by_container_serialize(
            id=id,
            container=container,
            device_profile_id=device_profile_id,
            device_id=device_id,
            audio_codec=audio_codec,
            enable_auto_stream_copy=enable_auto_stream_copy,
            audio_sample_rate=audio_sample_rate,
            audio_bit_rate=audio_bit_rate,
            audio_channels=audio_channels,
            max_audio_channels=max_audio_channels,
            static=static,
            copy_timestamps=copy_timestamps,
            start_time_ticks=start_time_ticks,
            width=width,
            height=height,
            max_width=max_width,
            max_height=max_height,
            video_bit_rate=video_bit_rate,
            subtitle_stream_index=subtitle_stream_index,
            subtitle_method=subtitle_method,
            max_video_bit_depth=max_video_bit_depth,
            video_codec=video_codec,
            audio_stream_index=audio_stream_index,
            video_stream_index=video_stream_index,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '400': None,
            '401': None,
            '403': None,
            '404': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def head_audio_by_id_stream_by_container_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="Item Id")],
        container: Annotated[StrictStr, Field(description="Container")],
        device_profile_id: Annotated[Optional[StrictStr], Field(description="Optional. The dlna device profile id to utilize.")] = None,
        device_id: Annotated[Optional[StrictStr], Field(description="The device id of the client requesting. Used to stop encoding processes when needed.")] = None,
        audio_codec: Annotated[Optional[StrictStr], Field(description="Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.")] = None,
        enable_auto_stream_copy: Annotated[Optional[StrictBool], Field(description="Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.")] = None,
        audio_sample_rate: Annotated[Optional[StrictInt], Field(description="Optional. Specify a specific audio sample rate, e.g. 44100")] = None,
        audio_bit_rate: Annotated[Optional[StrictInt], Field(description="Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.")] = None,
        audio_channels: Annotated[Optional[StrictInt], Field(description="Optional. Specify a specific number of audio channels to encode to, e.g. 2")] = None,
        max_audio_channels: Annotated[Optional[StrictInt], Field(description="Optional. Specify a maximum number of audio channels to encode to, e.g. 2")] = None,
        static: Annotated[Optional[StrictBool], Field(description="Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false")] = None,
        copy_timestamps: Annotated[Optional[StrictBool], Field(description="Whether or not to copy timestamps when transcoding with an offset. Defaults to false.")] = None,
        start_time_ticks: Annotated[Optional[StrictInt], Field(description="Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.")] = None,
        width: Annotated[Optional[StrictInt], Field(description="Optional. The fixed horizontal resolution of the encoded video.")] = None,
        height: Annotated[Optional[StrictInt], Field(description="Optional. The fixed vertical resolution of the encoded video.")] = None,
        max_width: Annotated[Optional[StrictInt], Field(description="Optional. The maximum horizontal resolution of the encoded video.")] = None,
        max_height: Annotated[Optional[StrictInt], Field(description="Optional. The maximum vertical resolution of the encoded video.")] = None,
        video_bit_rate: Annotated[Optional[StrictInt], Field(description="Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.")] = None,
        subtitle_stream_index: Annotated[Optional[StrictInt], Field(description="Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.")] = None,
        subtitle_method: Annotated[Optional[SubtitleDeliveryMethod], Field(description="Optional. Specify the subtitle delivery method.")] = None,
        max_video_bit_depth: Annotated[Optional[StrictInt], Field(description="Optional.")] = None,
        video_codec: Annotated[Optional[StrictStr], Field(description="Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.")] = None,
        audio_stream_index: Annotated[Optional[StrictInt], Field(description="Optional. The index of the audio stream to use. If omitted the first audio stream will be used.")] = None,
        video_stream_index: Annotated[Optional[StrictInt], Field(description="Optional. The index of the video stream to use. If omitted the first video stream will be used.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Gets an audio stream

        Requires authentication as user

        :param id: Item Id (required)
        :type id: str
        :param container: Container (required)
        :type container: str
        :param device_profile_id: Optional. The dlna device profile id to utilize.
        :type device_profile_id: str
        :param device_id: The device id of the client requesting. Used to stop encoding processes when needed.
        :type device_id: str
        :param audio_codec: Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
        :type audio_codec: str
        :param enable_auto_stream_copy: Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
        :type enable_auto_stream_copy: bool
        :param audio_sample_rate: Optional. Specify a specific audio sample rate, e.g. 44100
        :type audio_sample_rate: int
        :param audio_bit_rate: Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
        :type audio_bit_rate: int
        :param audio_channels: Optional. Specify a specific number of audio channels to encode to, e.g. 2
        :type audio_channels: int
        :param max_audio_channels: Optional. Specify a maximum number of audio channels to encode to, e.g. 2
        :type max_audio_channels: int
        :param static: Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
        :type static: bool
        :param copy_timestamps: Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
        :type copy_timestamps: bool
        :param start_time_ticks: Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
        :type start_time_ticks: int
        :param width: Optional. The fixed horizontal resolution of the encoded video.
        :type width: int
        :param height: Optional. The fixed vertical resolution of the encoded video.
        :type height: int
        :param max_width: Optional. The maximum horizontal resolution of the encoded video.
        :type max_width: int
        :param max_height: Optional. The maximum vertical resolution of the encoded video.
        :type max_height: int
        :param video_bit_rate: Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
        :type video_bit_rate: int
        :param subtitle_stream_index: Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
        :type subtitle_stream_index: int
        :param subtitle_method: Optional. Specify the subtitle delivery method.
        :type subtitle_method: SubtitleDeliveryMethod
        :param max_video_bit_depth: Optional.
        :type max_video_bit_depth: int
        :param video_codec: Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
        :type video_codec: str
        :param audio_stream_index: Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
        :type audio_stream_index: int
        :param video_stream_index: Optional. The index of the video stream to use. If omitted the first video stream will be used.
        :type video_stream_index: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._head_audio_by_id_stream_by_container_serialize(
            id=id,
            container=container,
            device_profile_id=device_profile_id,
            device_id=device_id,
            audio_codec=audio_codec,
            enable_auto_stream_copy=enable_auto_stream_copy,
            audio_sample_rate=audio_sample_rate,
            audio_bit_rate=audio_bit_rate,
            audio_channels=audio_channels,
            max_audio_channels=max_audio_channels,
            static=static,
            copy_timestamps=copy_timestamps,
            start_time_ticks=start_time_ticks,
            width=width,
            height=height,
            max_width=max_width,
            max_height=max_height,
            video_bit_rate=video_bit_rate,
            subtitle_stream_index=subtitle_stream_index,
            subtitle_method=subtitle_method,
            max_video_bit_depth=max_video_bit_depth,
            video_codec=video_codec,
            audio_stream_index=audio_stream_index,
            video_stream_index=video_stream_index,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '400': None,
            '401': None,
            '403': None,
            '404': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _head_audio_by_id_stream_by_container_serialize(
        self,
        id,
        container,
        device_profile_id,
        device_id,
        audio_codec,
        enable_auto_stream_copy,
        audio_sample_rate,
        audio_bit_rate,
        audio_channels,
        max_audio_channels,
        static,
        copy_timestamps,
        start_time_ticks,
        width,
        height,
        max_width,
        max_height,
        video_bit_rate,
        subtitle_stream_index,
        subtitle_method,
        max_video_bit_depth,
        video_codec,
        audio_stream_index,
        video_stream_index,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['Id'] = id
        if container is not None:
            _path_params['Container'] = container
        # process the query parameters
        if device_profile_id is not None:
            
            _query_params.append(('DeviceProfileId', device_profile_id))
            
        if device_id is not None:
            
            _query_params.append(('DeviceId', device_id))
            
        if audio_codec is not None:
            
            _query_params.append(('AudioCodec', audio_codec))
            
        if enable_auto_stream_copy is not None:
            
            _query_params.append(('EnableAutoStreamCopy', enable_auto_stream_copy))
            
        if audio_sample_rate is not None:
            
            _query_params.append(('AudioSampleRate', audio_sample_rate))
            
        if audio_bit_rate is not None:
            
            _query_params.append(('AudioBitRate', audio_bit_rate))
            
        if audio_channels is not None:
            
            _query_params.append(('AudioChannels', audio_channels))
            
        if max_audio_channels is not None:
            
            _query_params.append(('MaxAudioChannels', max_audio_channels))
            
        if static is not None:
            
            _query_params.append(('Static', static))
            
        if copy_timestamps is not None:
            
            _query_params.append(('CopyTimestamps', copy_timestamps))
            
        if start_time_ticks is not None:
            
            _query_params.append(('StartTimeTicks', start_time_ticks))
            
        if width is not None:
            
            _query_params.append(('Width', width))
            
        if height is not None:
            
            _query_params.append(('Height', height))
            
        if max_width is not None:
            
            _query_params.append(('MaxWidth', max_width))
            
        if max_height is not None:
            
            _query_params.append(('MaxHeight', max_height))
            
        if video_bit_rate is not None:
            
            _query_params.append(('VideoBitRate', video_bit_rate))
            
        if subtitle_stream_index is not None:
            
            _query_params.append(('SubtitleStreamIndex', subtitle_stream_index))
            
        if subtitle_method is not None:
            
            _query_params.append(('SubtitleMethod', subtitle_method.value))
            
        if max_video_bit_depth is not None:
            
            _query_params.append(('MaxVideoBitDepth', max_video_bit_depth))
            
        if video_codec is not None:
            
            _query_params.append(('VideoCodec', video_codec))
            
        if audio_stream_index is not None:
            
            _query_params.append(('AudioStreamIndex', audio_stream_index))
            
        if video_stream_index is not None:
            
            _query_params.append(('VideoStreamIndex', video_stream_index))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
            'apikeyauth', 
            'embyauth'
        ]

        return self.api_client.param_serialize(
            method='HEAD',
            resource_path='/Audio/{Id}/stream.{Container}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


